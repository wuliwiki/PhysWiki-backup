% 浮点数测试（Matlab）

\begin{itemize}
\item a 有 53 bit， 含正负号 1 bit． 大概范围是 $[-2,2]$
\item 指数有 11 bit． 范围是 $-1022,\dots,1023$， 因为 $-1024, -1023$ 用来表示 \verb|inf, nan| 等．
\end{itemize}

\begin{lstlisting}[language=matlab, caption=digits2.m]
% 求当前 vpa 变精度计算的有效数字
% digi_dec 是十进制有效数字
% digi_bin 是二进制有效数字
% eps 是最大相对精度
function [digi_dec, digi_bin, eps] = digits2
n = 0;
while true
    n = n + 1;
    if (1 + 2^(-vpa(n))) - 1 == 0
        break;
    end
end
digi_dec = n * log10(2) + 1;
digi_bin = n + 1;
eps = 2^(-n)
end
\end{lstlisting}

\begin{lstlisting}[language=matlab, caption=num2bin.m]
% x = a*2^Npw (exactly)
% 1 <= a < 2， 精度为 digits2() 输出的 eps
% 若 x 是双精度， 则 a 的绝对精度为 2^(-52), 也就是 eps
% 若 x 是单精度， 则 a 的绝对精度为 2^(-23), 也就是 eps('single')
% 最小的双精度为 2^(-52)*2^(-1022)， 最大的双精度为 (2-eps)*2^1023
function [a, Npow] = num2bin(x)
if isnan(x) || isinf(x)
    a = x; Npow = x; return;
end
sgn = sign(x); x = abs(vpa(x));
Npow = floor(log2(x));
a = sgn * (x * 2^(-Npow));
if a*2^Npow - sgn*x ~= 0
    error('something wrong!');
end
end
\end{lstlisting}

\begin{lstlisting}[language=matlab, caption=num2bin2.m]
% 精确解出 x = N*2^Npow， 其中 N 是绝对值最小的整数
function [N, Npow] = num2bin2(x)
N = x;
Npow = 0*x;
while true
    if mod(N, 1) == 0
        break;
    end
    N = 2 * N;
    Npow = Npow - 1;
end
while true
    if mod(N, 2) == 0
        N = N / 2;
        Npow = Npow + 1;
    else
        break;
    end
end
end
\end{lstlisting}
