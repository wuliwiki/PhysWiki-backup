% 简单稳定的多版本文件备份方案（含 python 实现）

\subsection{最原始的多版本备份方法}
为了防止文件被误删、误改、硬盘损坏等带来的文件丢失， 最普通原始的多版本方法大概要数复制粘贴了。 假设你笔记本上所有重要的文件都在一个文件夹 \verb|我的文件| 中。 为了安全起见你买了一个甚至多个移动硬盘， 每隔一段时间把它复制到硬盘中， 用不同的版本号（例如日期）命名为： \verb|我的文件夹v20230101|， \verb|我的文件夹v20230108| 等等。 但这样做的缺点是大量重复的文件会浪费移动硬盘空间， 写入这些文件也同样会浪费许多时间。 这时你很可能会发现很多支持\textbf{增量备份}的软件。 本文介绍一些备份的基本常识， 以及提供一些简单免费但非常可靠的备份方案。

在进一步讲解各种不同的增量备份方法之前， 我们需要知道计算机文件的构成， 以及如何检查其内容的完整性。

\subsection{计算机文件的构成}
计算机的硬盘中会有不同的文件系统， 例如 Windows 的 NTFS， MacOS 的 APFS， Linix 的 Ext4 等。 他们在一些特性上有所不同， 本文中不具体讨论。 先来看一些几乎所有文件系统都支持的信息：
\begin{itemize}
\item \textbf{文件名（含路径）}： 注意不同的文件系统或操作系统对名字的长度和包含的字符有不同的要求。
\item \textbf{文件内容}： 由若干\textbf{字节（Byte， 大写 B）}构成， 每个字节有 8 个比特（bit， 小写 b）， 每个比特就是一个二进制的 0 或 1。 文本文件（如 txt）和二进制文件（如 exe）的不同仅仅在于如何用 0 和 1 编码信息， 并无本质区别。
\item \textbf{文件大小}： 即上一条中文件内容的大小， 注意文件名的长度不会影响文件大小。 注意这并不是额外的信息， 而是包含在\textbf{文件内容}中的。 一些常见的单位有 \textbf{kB}（1000 byte）， \textbf{MB}（1000 kB）， \textbf{GB}（1000 MB）， \textbf{TB}（1000 MB）等。 注意严格来说这里都是 1000 而不是 1024（即 $2^{10}$）， 为了区分， 后者经常表示为 \textbf{kiB}（1024 byte）， \textbf{MiB}（1024 kB）， \textbf{GiB}（1024 MiB）等。
\item \textbf{修改时间}： 文件被修改的时间。 注意该时间并不是万无一失的， 软件和硬件\footnote{例如硬盘老化出现坏点， 也就是 bit rot， 但出现的概率较小。}上的错误都有可能导致文件内容被改变而修改时间没有更新。 更常见地， 也有可能修改时间更新了但内容实际上没有更新（例如打开文件不做任何修改就保存）。 修改时间属于文件的\textbf{元数据（meta data）}， 不储存于\textbf{文件内容}中。 别的元数据如\textbf{创建时间}， 由于并不是所有文件系统都支持， 我们不讨论。 可见如果用户想稳定地记录关于文件的一些时间， 最好记录在\textbf{文件内容}中（例如在 txt 文档中写下创建和修改时间）而不是依赖元数据。
\end{itemize}

本文假设我们只需要备份\textbf{文件名}（含路径）和\textbf{文件内容}（含文件大小）。

\subsection{增量备份}
常用的备份软件在进行增量备份时通常通过\textbf{文件大小}或\textbf{修改时间（元数据）}的变化来判断文件是否发生变化， 从而在每次增量备份时只备份它认为发生改变的文件。 但我们已经看到， 这两个信息并不绝对可靠， 软件或硬件错误都可以在不改变二者的情况下改变甚至破坏\textbf{文件内容}。 而一旦这些错误发生， 通常的备份软件并不能检测到。 更糟糕的是， 备份硬盘本身也可能随着其老化和磨损出现坏点， 而常用的备份软件一般不具有检查备份数据完整性的功能。 即使使用不同硬盘进行多重备份， 也

\subsection{文件指纹：哈希值}
上面我们已经知道用文件大小

\subsection{用网盘增量备份}
现在大部分网盘都支持所谓的
