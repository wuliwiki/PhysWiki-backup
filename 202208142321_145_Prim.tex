% 最小生成树
% keys Pirm|最小生成树|算法|C++

\begin{issues}
\issueMissDepend
\end{issues}

生成树的定义：是指在一个带权的无向联通图中选择 $n$ 个点和 $n - 1$ 条边构成的无向联通子图．

最小生成树的定义即为边权最小的生成树．

求最小生成树最常用的两种算法为：Prim 和 Kruskal．Prim 常用于稠密图，Kruskal 则相反．

\subsection{Prim 算法}

Prim 算法的思路与 Dijkstra 算法非常相似．
定义 $S$ 为当前已经确定了属于最小生成树的结点，$T$ 为集合外的结点．使用 \verb|dist| 数组存储每个结点到 $S$ 集合的距离，距离定义为如果有多个结点指向 $S$ 集合，则距离最短的边为这个结点到 $S$ 集合的距离．最开始初始化所有结点到 $S$ 集合的距离为 $+\infty$，$1$ 号点到 $S$ 集合的距离为 $0$．一共进行 $n$ 次迭代，每次找到 $T$ 集合中距离 $S$ 集合距离最短的结点 $t$，然后用 $t$ 结点更新其他点（与 $t$ 相连的结点）到 $S$ 集合的距离，然后把 $t$ 从 $T$ 集合中删去，加入到 $S$ 集合中，则 $t$ 结点为当前已经确定了属于最小生成树的结点．具体的更新方法是：看一下 $t$ 号结点的所有出边 $(t, y, w)$（$t$ 号点与 $y$ 号点之间有一条边，权值为 $w$），若 \verb|dist[y] > dist[t] + w|，则使用 \verb|dist[t] + w| 更新 \verb|dist[y]|．具体的做法是用一个布尔数组来标记一个点是否属于 $S$ 集合，\verb|st[i]| 为 \verb|true| 则结点 $i$ 属于 $S$ 集合，反之不属于．每次从未标记的结点中选择一个