% 图灵机到真实计算机
% license Usr
% type Tutor

\begin{issues}
\issueDraft
\end{issues}

\pentry{}{nod_cab0}

\textbf{图灵机要素}：无限长纸带、有限字符集、有限的状态集、根据状态和当前字符决定下一步行为（写入、移动）、初始状态、停机状态。

图灵可以完成任何计算机可以完成的事情。如果一个编程语言可以做图灵机的任何事情（除了纸带不是无限长），那么他就是图灵完备的。

\subsubsection{真实计算机}
\textbf{纸带被划分为几个部分}：\textbf{代码段}（储存程序指令，一般只读）、\textbf{数据段}（分为只读和读写，只读部分是 literal，读写部分是全局变量和 static 变量）、\textbf{栈}（函数局部变量）、\textbf{堆}（动态分配内存）。

\begin{itemize}
\item \textbf{变量}没有类型，就对应一个地址和长度
\item 没有算符更没有重载，只有\textbf{函数}，每个函数对应一个函数地址
\item 内存不区分 stack 和 heap，每个函数从内存固定几个地址读取固定长度的函数参数，输出到固定地址固定长度。
\item 这其实就是更具体的图灵机，纸带划分为指令部分和内存部分。每个周期，图灵机先从 program counter 读取下一个要执行的指令、该指令要操作的数据在内存中的固定地址，然后计算（“与非”或“或非”或NANA）。
\item 更具体的图灵机：可以认为图灵机本身包含了 cpu 的硬件运算能力，实现与、或、非、整数和浮点数加法等（其实最基本的只要掌握，其他硬件能力都可以用代码段来软实现），也包含了这些运算所需的寄存器。程序计数器。
\item \textbf{纸带被划分为几个部分}：\textbf{代码段}（储存程序指令，一般只读）、\textbf{数据段}（分为只读和读写，只读部分是 literal，读写部分是全局变量和 static 变量）、\textbf{栈}（函数局部变量）、\textbf{堆}（动态分配内存）。
\item \textbf{静态类型只是用于辅助编译器帮用户检查是否函数用对了，编译完成后静态类型丢失，所有的函数的参数都只是给定位置的一串 0 和 1}
\item \textbf{静态类型的唯一作用就是告诉编译器应该选择什么函数地址！否则用户完全可以所有变量都使用 \verb`const void *`。 甚至连每个变量的字节数都不需要用别的变量储存，因为每个函数是知道每个变量的长度的。}
\item \textbf{人类很喜欢 overload，机器不喜欢。 即使是 C 语言也有 overload 例如 \verb`+` 算符其实不是一个函数地址（或者 cpu 指令），而是根据变量类型决定具体用哪一个，只是不能用户定义罢了。 C++ 把 overload 推向了全新的境界。}
\item \textbf{多态（polymorphism）}主要指的是运行时的类型多态。 运行时多态和普通函数重载有本质区别。 前者根据运行时变量的值决定调用哪个地址的函数，而普通函数重载是编译时写死到代码段，运行时无法改变。另外，运行时也会有方法多态。
\end{itemize}
