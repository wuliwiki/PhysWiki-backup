% 计算机算数


要了解科学计算，首先要知道数据是如何在计算机中存储和表达的．在计算机基础中我们知道，所有的数据在计算机内存中都是以二进制数的形式存储的，但对于不同的数据类型，二进制数所代表的意义也不尽相同．下面我们来看两种最常见的数据类型：整数和浮点数．</p><h2>1. 整数</h2>很自然的，对于一个给定的十进制整数，可以将它转换为二进制数，从而在计算机中表示． 下图中的8位（8 bits）二进制数，</p>

表示

 $(01011101)2=0\cdot2^7+1\cdot2^6+0\cdot2^5+1\cdot2^4+1\cdot2^3+1\cdot2^2+0\cdot2^1+1\cdot2^0=(93)_{10}\\$  

从Python3.0起，可以表示的整数的最大值上限被移除<sup data-text="python3 int" data-url="https://docs.python.org/3.1/whatsnew/3.0.html#integers" data-numero="1" data-draft-node="inline" data-draft-type="reference" data-tooltip="python3 int https://docs.python.org/3.1/whatsnew/3.0.html#integers" data-tooltip-preset="white" data-tooltip-classname="ztext-referene-tooltip"><a id="ref_1_0" href="#ref_1" data-reference-link="true" aria-labelledby="ref_1">[1]</a></sup>，这就意味着我们可以精确表示任何整数，也就是说只要将给定的整数转换为二进制数，然后占用相应长度的内存空间即可．理论上16G的内存可以存储的最大整数约为  $10^{5.17\times10^9}$  ．

另外，由于两个不同整数之间的最小间隔为1（整数的机器精度），因此，与整数有关的加、减和乘法都可以被精确计算，并且没有任何舍入误差．</p><h3>例子1: 大整数及其运算</h3>\textbf{注1}:普通除法运算  \verb|/|  在Python中会默认转换为浮点数，因此并不能保证完全精确．

\textbf{注2}:整数除法 \verb|//| 可以保证精确，但是结果只有商，余数可以用 \verb|%|  求得．</p><div class="highlight"><pre><code class="language-python"><span class="n">a</span> <span class="o">=</span> <span class="mi">135791113151719</span>


输出：</p><div class="highlight"><pre><code class="language-text">a=135791113151719, b=246810 
a+b=135791113398529 
a-b=135791112904909 
axb=33514604636975766390 
a÷b=550184810......195619| </pre></div><hr/><h2>2. 浮点数</h2>不同于整数，实数是连续的，这就意味着两个不相同的实数之间的最小距离可以无限接近于0． 前文中对于整数的存储方式显然不再适用，我们并不能把所有实数都在计算机中表示出来． 甚至我们都不能把0到1之间的所有实数表达出来．

这就要求计算机对实数运算进行一定的近似，使得给定任意一个实数，我们都能找到一个与它接近的计算机浮点数表达．同时，计算机浮点数系统需要保证\textbf{运算精度}和\textbf{速度}．这就要求计算机浮点数系统需要尽可能满足下面的条件：</p><ol><li>每个浮点数占用的内存空间一致．</li><li>覆盖的范围尽可能大</li><li>舍入误差或机器精度尽可能的小．关于舍入误差，参见我之前的文章</li></ol><a target="_blank" href="https://zhuanlan.zhihu.com/p/118757498" data-draft-node="block" data-draft-type="link-card" data-image="https://pic2.zhimg.com/v2-8fb1f6237306f2141adb0f9aa9f14ccd_180x120.jpg" data-image-width="650" data-image-height="435" class="LinkCard old LinkCard--hasImage"><span class="LinkCard-backdrop" style="background-image:url(https://pic2.zhimg.com/v2-8fb1f6237306f2141adb0f9aa9f14ccd_180x120.jpg)"></span><span class="LinkCard-content"><span class="LinkCard-text"><span class="LinkCard-title" data-text="true">Gong Cheng：科学计算基础（1）——误差</span><span class="LinkCard-meta"><span style="display:inline-flex;align-items:center">​<svg class="Zi Zi--InsertLink" fill="currentColor" viewBox="0 0 24 24" width="17" height="17"><path d="M13.414 4.222a4.5 4.5 0 1 1 6.364 6.364l-3.005 3.005a.5.5 0 0 1-.707 0l-.707-.707a.5.5 0 0 1 0-.707l3.005-3.005a2.5 2.5 0 1 0-3.536-3.536l-3.005 3.005a.5.5 0 0 1-.707 0l-.707-.707a.5.5 0 0 1 0-.707l3.005-3.005zm-6.187 6.187a.5.5 0 0 1 .638-.058l.07.058.706.707a.5.5 0 0 1 .058.638l-.058.07-3.005 3.004a2.5 2.5 0 0 0 3.405 3.658l.13-.122 3.006-3.005a.5.5 0 0 1 .638-.058l.069.058.707.707a.5.5 0 0 1 .058.638l-.058.069-3.005 3.005a4.5 4.5 0 0 1-6.524-6.196l.16-.168 3.005-3.005zm8.132-3.182a.25.25 0 0 1 .353 0l1.061 1.06a.25.25 0 0 1 0 .354l-8.132 8.132a.25.25 0 0 1-.353 0l-1.061-1.06a.25.25 0 0 1 0-.354l8.132-8.132z"></path></svg></span>zhuanlan.zhihu.com</span></span><span class="LinkCard-imageCell"> $图标" src="https://pic2.zhimg.com/v2-8fb1f6237306f2141adb0f9aa9f14ccd_180x120.jpg"/></span></span></a>下面我们会一步一步的设计一个8位（8 bits）的浮点数系统，也就是用8位的256个二进制数字来表达浮点数，并逐步满足上述条件． 从而探究一下真正的IEEE浮点数标准是如何设计和指定的． 整个的这个设计过程，也可以在我的网络课件中找到： </p><h3>2.1 简单的二进制表达浮点数</h3>类似二进制以 \verb|2| 为基的方式，我们也可以用  $\frac{1}{2}$  为基，那么下图的这个8位二进制数就表示</p><figure data-size="normal"><noscript> $(01011101)_2=0\cdot2^{-1}+1\cdot2^{-2}+0\cdot2^{-3}+1\cdot2^{-4}+1\cdot2^{-5}+1\cdot2^{-6}+0\cdot2^{-7}+1\cdot2^{-8}=0.36328125\\$  

事实上，这个8位二进制数和前面整数一章用到的是同一个二进制数，但他们因为数据类型不同，代表的含义也就不同了．

由此，我们的8位浮点数系统可以表示256个在0到  $1-\frac{1}{2^8}=0.99609375$  之间的实数，它们的机器精度为  $\frac{1}{2^8}=0.00390625$  ．

\textbf{小结}：<u>此方法的机器精度是8位系统可达到的最小值，但覆盖范围仅为0到1</u>．</p><h3>2.2 扩大范围</h3>想要表达更大的数，可以从上面的方式出发，将得到的0到1之间的数都乘以一个固定的值，例如乘以8． 这样，我们的浮点数系统的覆盖范围扩大到了0到7.96875． 但是这个操作也会将机器精度乘以相应的值，使其下降为了  $\frac{1}{2^5}=0.03125$  ．

\textbf{小结}：<u>等比例的扩大范围会大幅降低机器精度</u>．</p><h3>2.3 标准化</h3>延续上面的思路，我们可以用乘以多个不同的倍数的方法来控制所扩大的范围． 也就是说，从8位二进制中拿出2位（下面的例子中用的是最后两位，但也可以是前面两位），用来记录扩大的倍数，而前面的6位同之前一样用作表达0到1之间的实数，这6位被称作尾数位（mantissa）． 

为了进一步扩大范围，取出的2位从二进制转化为十进制后，被放在以 \verb|2| 为基（basis）的指数位置上形成放大的倍数，因此这2位在这个系统中被称为指数位（exponent）．

如下图，我们继续使用同样的8位二进制数，在经过标准化过程后，表达的数为</p><figure data-size="normal"><noscript> $\frac{1}{2^6}=0.015625$  ．

\textbf{小结}：<u>此方法在保持了与2.2相似的范围的同时，将机器精度提升了一倍</u>．

\textbf{但是}，我们注意到，这个方法有一个严重的问题在于\textbf{重复}，例如01011101和10111000都表示了同一个数．</p><h3>2.4 去掉重复</h3>去掉重复数字的方法很巧妙，这个方法并不改变2.3中的标准化方式，只是在对尾数位求和过程中加上一个常数1，即

 $(01011101)_2=({\color{red}{1}}+0\cdot2^{-1}+1\cdot2^{-2}+0\cdot2^{-3}+1\cdot2^{-4}+1\cdot2^{-5}+1\cdot2^{-6})\times2^1=2.71875\\$  

使用这种改进方法，我们可以表达1至15.875之间的256个不同的实数， 我们把这些浮点数画在数轴上，如下图</p><figure data-size="normal"><noscript> $\frac{1}{2^6}=0.015625$  ．

\textbf{注}：数轴上小于1的范围称为下溢（underflow），而超过15.875的范围称为上溢（overflow）．</p><h3>2.5 更多的</h3>下面的几个步骤可以进一步完善我们的浮点数系统： </p><ul><li>为了表达负数，我们需要从尾数位（mantissa）中取出一位，作为\textbf{符号位}．  </li><li>为了将下溢降低，我们将指数位（exponent）表达的十进制数（0,1,2,3）向负数平移，变成（-1,0,1,2）．</li></ul><h3>3. IEEE 浮点数标准</h3>现在的计算机系统采用的是</p><a target="_blank" href="https://link.zhihu.com/?target=https%3A//ieeexplore.ieee.org/document/8766229" data-draft-node="block" data-draft-type="link-card" class="LinkCard old LinkCard--noImage"><span class="LinkCard-content"><span class="LinkCard-text"><span class="LinkCard-title" data-text="true">754-2019 - IEEE Standard for Floating-Point Arithmetic - IEEE Standard</span><span class="LinkCard-meta"><span style="display:inline-flex;align-items:center">​<svg class="Zi Zi--InsertLink" fill="currentColor" viewBox="0 0 24 24" width="17" height="17"><path d="M13.414 4.222a4.5 4.5 0 1 1 6.364 6.364l-3.005 3.005a.5.5 0 0 1-.707 0l-.707-.707a.5.5 0 0 1 0-.707l3.005-3.005a2.5 2.5 0 1 0-3.536-3.536l-3.005 3.005a.5.5 0 0 1-.707 0l-.707-.707a.5.5 0 0 1 0-.707l3.005-3.005zm-6.187 6.187a.5.5 0 0 1 .638-.058l.07.058.706.707a.5.5 0 0 1 .058.638l-.058.07-3.005 3.004a2.5 2.5 0 0 0 3.405 3.658l.13-.122 3.006-3.005a.5.5 0 0 1 .638-.058l.069.058.707.707a.5.5 0 0 1 .058.638l-.058.069-3.005 3.005a4.5 4.5 0 0 1-6.524-6.196l.16-.168 3.005-3.005zm8.132-3.182a.25.25 0 0 1 .353 0l1.061 1.06a.25.25 0 0 1 0 .354l-8.132 8.132a.25.25 0 0 1-.353 0l-1.061-1.06a.25.25 0 0 1 0-.354l8.132-8.132z"></path></svg></span>ieeexplore.ieee.org</span></span><span class="LinkCard-imageCell"><div class="LinkCard-image LinkCard-image--default"><svg class="Zi Zi--Browser" fill="currentColor" viewBox="0 0 24 24" width="32" height="32"><path d="M11.991 3C7.023 3 3 7.032 3 12s4.023 9 8.991 9C16.968 21 21 16.968 21 12s-4.032-9-9.009-9zm6.237 5.4h-2.655a14.084 14.084 0 0 0-1.242-3.204A7.227 7.227 0 0 1 18.228 8.4zM12 4.836A12.678 12.678 0 0 1 13.719 8.4h-3.438A12.678 12.678 0 0 1 12 4.836zM5.034 13.8A7.418 7.418 0 0 1 4.8 12c0-.621.09-1.224.234-1.8h3.042A14.864 14.864 0 0 0 7.95 12c0 .612.054 1.206.126 1.8H5.034zm.738 1.8h2.655a14.084 14.084 0 0 0 1.242 3.204A7.188 7.188 0 0 1 5.772 15.6zm2.655-7.2H5.772a7.188 7.188 0 0 1 3.897-3.204c-.54.999-.954 2.079-1.242 3.204zM12 19.164a12.678 12.678 0 0 1-1.719-3.564h3.438A12.678 12.678 0 0 1 12 19.164zm2.106-5.364H9.894A13.242 13.242 0 0 1 9.75 12c0-.612.063-1.215.144-1.8h4.212c.081.585.144 1.188.144 1.8 0 .612-.063 1.206-.144 1.8zm.225 5.004c.54-.999.954-2.079 1.242-3.204h2.655a7.227 7.227 0 0 1-3.897 3.204zm1.593-5.004c.072-.594.126-1.188.126-1.8 0-.612-.054-1.206-.126-1.8h3.042c.144.576.234 1.179.234 1.8s-.09 1.224-.234 1.8h-3.042z"></path></svg></div></span></span></a>每一个浮点数（Python中的 \verb|float| 类型）占用64位．如下图所示，其中第1位为符号位，下面11位为指数位（exponent），最后52位为尾数位（mantissa）．</p><figure data-size="normal"><noscript> $f=\frac{i}{2^{52}},\quad i=0,1,2,...,2^{52}-1$  ．指数位  $e$  的标准范围定为  $-1022\le e\le 1023$  ，把  $e=1024$  作为特殊位，并把  $e=-1023$  作为保留位（我们放在最后分析）．

由此，我们可以求得：</p><ul><li>机器精度 \verb|eps| 为  $\frac{1}{2^{52}}\approx 2.220446049250313\times10^{-16}$  ．</li><li>最小的正浮点数 \verb|realmin| 为  $2^{-1022}\approx2.2251\times10^{-308}$  ，在python中可以通过 \verb|numpy.finfo(float).tiny| 获得．</li><li>最大的浮点数 \verb|realmax| 为 $(2-2^{-52})\times2^{1023}\approx1.7977\times10^{308}$  ，在python中可以通过 \verb|numpy.finfo(float).max| 获得．</li><li>令  $e=1024$  和  $f=0$  ，表示无穷大  $\infty$  ，即任何大于 \verb|realmax| 的数，在python中可以通过 \verb|numpy.inf| 得到．</li><li>令  $e=1024$  且  $f\neq0$  ，则表示这不是一个数（NaN，Not a Number）．通常出作为 \verb|0/0| 或者 \verb|numpy.inf-numpy.inf| 的结果．我们也可以通过 \verb|numpy.nan| 表达它．</li></ul><h3>例子2: numpy中查看浮点数标准</h3><div class="highlight"><pre><code class="language-python"><span class="kn">import</span> <span class="nn">numpy</span> <span class="kn">as</span> <span class="nn">np</span>


输出</p><div class="highlight"><pre><code class="language-pycon">minimal positive normal float: 2.2250738585072014e-308 
maximal float: 1.7976931348623157e+308 
machine epsilon: 2.220446049250313e-16 
infinity: inf 
not a number: nan| </pre></div><h3>3.1 亚标准（subnormal）</h3>在很多计算系统中，除了上面的标准浮点数以外，还存在着亚标准浮点数（subnormal floating point numbers）． 

它们是比最小的标准浮点数 \verb|realmin| （  $2.2251\times10^{-308}$  ）还要小的正实数．

我们先来看一下下面这个例子：</p><div class="highlight"><pre><code class="language-python"><span class="kn">import</span> <span class="nn">numpy</span> <span class="kn">as</span> <span class="nn">np</span>

可以看到</p><ul><li>我们能够表示比最小标准数 \verb|realmin| 更小的一些正实数；</li><li>它们的精度随着我们远离 \verb|realmin| 而降低；</li><li>最终，当这个数与 \verb|realmin| 的比小于约  $10^{-16}$  时，它变成了0．</li></ul>这是因为，我们是用保留位  $e=-1023$  来表示这类亚标准浮点数，它们范围为 \verb|realmin|   $\times$   \verb|eps| 到realmin（eps为机器精度）．也就是说，我们能表示的最最小的正实数为  $2^{-(1022+52)}\approx 0.494\times10^{-323}$  ，但这个数的精度非常低．

\textbf{注}：这里尽管  $e=-1023$  ，但我们并不是用标准浮点数的转换规则进行运算的，同时在尾数前面加的1也并没有在这出现．
