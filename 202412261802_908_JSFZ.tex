% 计算复杂性理论（综述）
% license CCBYSA3
% type Wiki

本文根据 CC-BY-SA 协议转载翻译自维基百科\href{https://en.wikipedia.org/wiki/Computational_complexity_theory}{相关文章}。

在理论计算机科学和数学中，计算复杂性理论专注于根据资源使用情况对计算问题进行分类，并探索这些分类之间的关系。计算问题是由计算机解决的任务。一个计算问题可以通过机械地应用数学步骤（如算法）来解决。

如果一个问题的解决需要大量资源，无论使用何种算法，都被视为固有的困难问题。该理论通过引入计算模型来正式化这种直觉，以研究这些问题并量化它们的计算复杂性，即解决问题所需的资源量，如时间和存储空间。还使用其他复杂性度量，如通信量（用于通信复杂性）、电路中的门数（用于电路复杂性）以及处理器数量（用于并行计算）。计算复杂性理论的一个重要作用是确定计算机能够做什么以及不能做什么的实际限制。P与NP问题，作为七大千年奖问题之一，是计算复杂性领域的一部分。

在理论计算机科学中，与计算复杂性紧密相关的领域有算法分析和可计算性理论。算法分析与计算复杂性理论之间的一个关键区别是，前者致力于分析特定算法解决问题所需的资源量，而后者则提出一个更为一般的问题，即所有可能用于解决同一问题的算法。更精确地说，计算复杂性理论试图对能够或不能在适当限制的资源下解决的问题进行分类。反过来，施加对可用资源的限制是计算复杂性与可计算性理论的区别所在：后者理论探讨的是哪些类型的问题原则上可以通过算法解决。
\subsection{计算问题}
\subsubsection{问题实例}  
\begin{figure}[ht]
\centering
\includegraphics[width=8cm]{./figures/7bac2fedcf74bc30.png}
\caption{穿越14个德国城市的旅行推销员之旅} \label{fig_JSFZ_1}
\end{figure}
一个计算问题可以视为一个无限的实例集合，每个实例都有一组（可能为空）的解。计算问题的输入字符串称为问题实例，不应与问题本身混淆。在计算复杂性理论中，问题指的是待解决的抽象问题。与此相对，问题的一个实例是一个相对具体的表述，可以作为决策问题的输入。例如，考虑素数测试问题。实例是一个数字（例如，15），如果该数字是素数，解答是“是”，否则是“否”（在这种情况下，15不是素数，答案是“否”）。换句话说，实例是问题的特定输入，解答是与该输入对应的输出。

为了进一步突出问题和实例之间的区别，考虑旅行商问题的决策版本实例：是否存在一条最多2000公里的路线，经过德国的15个最大城市？对于这个特定问题实例的定量答案，对解决问题的其他实例帮助不大，例如询问一条在米兰所有景点之间，且总长度不超过10公里的环路。因此，复杂性理论关注的是计算问题，而不是特定的问题实例。
\subsubsection{表示问题实例}  
在考虑计算问题时，问题实例通常是一个由字母表组成的字符串。通常，字母表被视为二进制字母表（即{0, 1}集合），因此这些字符串是位字符串。如同实际计算机一样，必须对除位字符串外的数学对象进行适当的编码。例如，整数可以用二进制表示，图形可以通过其邻接矩阵直接编码，或者通过将其邻接表编码为二进制来表示。

尽管一些复杂性理论定理的证明通常假设某种具体的输入编码选择，但讨论通常保持足够抽象，以独立于编码选择。这可以通过确保不同的表示方法可以高效地相互转换来实现。
\subsubsection{决策问题作为形式语言}
\begin{figure}[ht]
\centering
\includegraphics[width=6cm]{./figures/25153b00e03e1d07.png}
\caption{决策问题对于任何输入只有两个可能的输出：是（yes）或否（no），或者分别表示为1或0。} \label{fig_JSFZ_2}
\end{figure}
决策问题是计算复杂性理论中研究的核心对象之一。决策问题是一种计算问题，其答案是“是”或“否”（也可以是1或0）。决策问题可以被视为一种形式语言，其中语言的成员是那些输出为“是”的实例，而非成员则是那些输出为“否”的实例。目标是借助算法来判断给定的输入字符串是否是所考虑的形式语言的成员。如果决定该问题的算法返回“是”作为答案，则称该算法接受该输入字符串，否则称其拒绝该输入。

一个决策问题的例子是以下问题：输入是一个任意图。问题的内容是判断给定的图是否是连通的。与此决策问题相关的形式语言是所有连通图的集合——为了精确定义这个语言，需要决定如何将图编码为二进制字符串。
\subsubsection{函数问题}
函数问题是一种计算问题，其中每个输入期望一个单一的输出（来自一个总函数），但输出比决策问题更复杂——即输出不仅仅是“是”或“否”。著名的例子包括旅行推销员问题和整数分解问题。

人们可能会认为，函数问题的概念比决策问题的概念要丰富得多。然而，事实并非如此，因为函数问题可以转化为决策问题。例如，两个整数的乘法可以表示为一组三元组 \((a, b, c)\)，使得 \(a \times b = c\) 成立。判断给定三元组是否属于该集合，相当于解决两个数相乘的问题。
\subsubsection{衡量实例的大小}
为了衡量解决一个计算问题的难度，可能需要了解解决该问题的最佳算法所需的时间。然而，运行时间通常依赖于实例的大小。特别是，较大的实例需要更多时间来解决。因此，解决一个问题所需的时间（或所需的空间，或任何复杂度度量）是作为实例大小的函数来计算的。输入大小通常以比特为单位衡量。复杂度理论研究算法在输入大小增加时的扩展性。例如，在判断一个图是否连通的问题中，对于一个拥有 \(2n\) 个顶点的图，相比于一个拥有 \(n\) 个顶点的图，解决该问题需要更多的时间吗？

如果输入大小是 \(n\)，则所需的时间可以表示为 \(n\) 的函数。由于对于相同大小的不同输入，所需的时间可能不同，因此定义最坏情况下的时间复杂度 \(T(n)\) 为所有大小为 \(n\) 的输入所需时间的最大值。如果 \(T(n)\) 是 \(n\) 的多项式，则称该算法为多项式时间算法。科布汉的论题（Cobham's thesis）认为，如果一个问题能够通过多项式时间算法解决，那么它可以用合理的资源量来解决。
\subsection{机器模型与复杂度度量} 
\subsubsection{图灵机}
\begin{figure}[ht]
\centering
\includegraphics[width=8cm]{./figures/f6fabba661416c09.png}
\caption{} \label{fig_JSFZ_3}
\end{figure}
图灵机是一种通用计算机的数学模型。它是一个理论设备，能够操作带有符号的磁带。图灵机并非作为一种实际的计算技术出现，而是作为计算机的通用模型——从高级超级计算机到拿着铅笔和纸的数学家都可以视为图灵机的实现。人们相信，如果一个问题可以通过算法解决，那么就存在一个图灵机能够解决该问题。这正是教会-图灵论题的表述。此外，已知任何我们今天所知的其他计算模型（如RAM机、康威的生命游戏、元胞自动机、λ演算或任何编程语言）也能在图灵机上进行计算。由于图灵机容易进行数学分析，并且被认为与其他计算模型具有同等的计算能力，因此在复杂度理论中，图灵机是最常用的模型。

有许多类型的图灵机被用来定义复杂度类，例如确定性图灵机、概率图灵机、非确定性图灵机、量子图灵机、对称图灵机和交替图灵机。它们在原则上都是同等强大的，但当资源（如时间或空间）受到限制时，有些可能比其他的更强大。

确定性图灵机是最基本的图灵机，它使用一组固定的规则来确定未来的操作。概率图灵机是一个附加了随机比特的确定性图灵机。做出概率性决策的能力通常有助于算法更高效地解决问题。使用随机比特的算法被称为随机算法。非确定性图灵机是一个带有非确定性特性的确定性图灵机，它允许图灵机在给定状态下有多个可能的未来动作。非确定性的一种看法是，图灵机在每一步都分裂成许多可能的计算路径，如果它在任何这些路径中成功解决问题，那么就认为它已经解决了问题。显然，这个模型并不是为了作为一个物理上可实现的模型，它只是一个在理论上非常有趣的抽象机器，并且它催生了特别有趣的复杂度类。例如，非确定性算法就是这一模型的一个实例。
\subsubsection{其他机器模型}  
在文献中，提出了许多与标准的多带图灵机不同的机器模型，例如随机访问机器。令人惊讶的是，这些模型中的每一个都可以转换为另一个，而不会提供任何额外的计算能力。这些替代模型的时间和内存消耗可能会有所不同。[2] 这些模型的共同点是，它们的操作是确定性的。

然而，一些计算问题在更不寻常的资源模型下更容易分析。例如，非确定性图灵机是一种计算模型，允许它在同一时刻分支出多个不同的可能性。非确定性图灵机与我们物理上如何计算算法几乎没有关系，但它的分支正好捕捉了许多我们想要分析的数学模型，因此非确定性时间在分析计算问题时是一个非常重要的资源。
\subsubsection{复杂度度量 } 
为了准确地定义在给定时间和空间内解决一个问题的含义，通常使用像确定性图灵机这样的计算模型。对于确定性图灵机 \( M \) 和输入 \( x \)，所需的时间是机器在停止并输出答案（“是”或“否”）之前所做的状态转换或步骤的总数。如果一个图灵机 \( M \) 在每个长度为 \( n \) 的输入上所需的时间最多为 \( f(n) \)，则称其在时间 \( f(n) \) 内运行。若存在一个在时间 \( f(n) \) 内运行的图灵机 \( M \) 可以解决决策问题 \( A \)，则可以说该问题在时间 \( f(n) \) 内可解。由于复杂度理论关注的是根据问题的难度对问题进行分类，因此可以根据某些标准定义问题的集合。例如，在确定性图灵机上可以在时间 \( f(n) \) 内解决的所有问题集合，记作 \( \text{DTIME}(f(n)) \)。

对于空间需求，可以做类似的定义。尽管时间和空间是最常见的复杂度资源，但任何复杂度度量都可以视为一种计算资源。复杂度度量通常通过布鲁姆复杂度公理进行定义。复杂度理论中使用的其他复杂度度量包括通信复杂度、电路复杂度和决策树复杂度。

算法的复杂度通常使用大O符号表示。
\subsubsection{最佳、最差和平均情况复杂度}
\begin{figure}[ht]
\centering
\includegraphics[width=8cm]{./figures/7a3f8a81d25494f3.png}
\caption{快速排序算法的可视化，其平均时间复杂度为 \( O(n \log n) \)} \label{fig_JSFZ_4}
\end{figure}
最佳、最差和平均情况复杂度是衡量相同大小的不同输入的时间复杂度（或任何其他复杂度度量）三种不同方式。由于大小为 \( n \) 的某些输入可能比其他输入更容易解决，因此我们定义以下几种复杂度：
\begin{enumerate}
\item 最佳情况复杂度：这是解决大小为 \( n \) 的问题时，针对最佳输入的复杂度。
\item 平均情况复杂度：这是解决问题的平均复杂度。该复杂度仅在输入上有概率分布时定义。例如，如果假设所有相同大小的输入出现的概率相同，则可以根据大小为 \( n \) 的所有输入的均匀分布来定义平均情况复杂度。
\item 摊销分析：摊销分析考虑了算法整个操作序列中的昂贵操作和较便宜操作的综合。
\item 最差情况复杂度：这是解决大小为 \( n \) 的问题时，针对最差输入的复杂度。
\end{enumerate}
从便宜到昂贵的顺序为：最佳情况、平均情况（离散均匀分布）、摊销、最差情况。

例如，确定性排序算法快速排序解决的是排序整数列表的问题。最差情况是当每次选择的基准值都是列表中的最大或最小值（因此列表从未被分割）。在这种情况下，算法的时间复杂度是 \( O(n^2) \)。如果假设输入列表的所有可能排列的出现概率相同，则排序的平均时间复杂度为 \( O(n\log n) \)。最佳情况发生在每次基准分割列表为两半时，这时也需要 \( O(n\log n) \) 时间。
\subsubsection{问题复杂度的上下界}
为了对计算时间（或类似资源，如空间消耗）进行分类，展示求解给定问题的最有效算法所需的最大时间的上界和下界是有帮助的。算法的复杂度通常被认为是其最差情况复杂度，除非另有说明。分析特定算法属于算法分析领域。为了展示一个问题的时间复杂度的上界 \( T(n) \)，只需要展示某个算法的运行时间最多为 \( T(n) \)。然而，证明下界要困难得多，因为下界是对所有能够解决给定问题的可能算法作出的声明。这里的“所有可能的算法”不仅包括今天已知的算法，还包括未来可能发现的任何算法。要展示问题的下界为 \( T(n) \)，需要证明没有任何算法能有比 \( T(n) \) 更低的时间复杂度。

上下界通常使用大O符号表示，这样可以隐藏常数因子和较小的项。这样，复杂度的上下界与所使用的具体计算模型的细节无关。例如，如果 \( T(n) = 7n^2 + 15n + 40 \)，在大O符号中会写成 \( T(n) = O(n^2) \)。
\subsection{复杂度类}
\subsubsection{定义复杂度类}

复杂度类是具有相关复杂度的各种问题的集合。更简单的复杂度类通常由以下因素定义：
\begin{itemize}
\item 计算问题的类型：最常用的问题是决策问题。然而，复杂度类也可以基于函数问题、计数问题、优化问题、承诺问题等来定义。  
\item 计算模型：最常见的计算模型是确定性图灵机，但许多复杂度类是基于非确定性图灵机、布尔电路、量子图灵机、单调电路等定义的。
\item 被限制的资源（或资源）和限制条件：这两个属性通常一起陈述，如“多项式时间”、“对数空间”、“常深度”等。
\end{itemize}
有些复杂度类的定义非常复杂，无法适应这一框架。因此，一个典型的复杂度类通常有类似以下的定义：

决策问题的集合：这些问题可以由确定性图灵机在时间 \( f(n) \) 内解决。（这个复杂度类被称为 DTIME(\( f(n) \))）

然而，将计算时间通过某个具体的函数 \( f(n) \) 上限化，往往会导致依赖于所选择的机器模型的复杂度类。例如，语言集合 \(\{xx \mid x \text{ 是任何二进制字符串} \}\) 可以在多带图灵机上在线性时间内解决，但在单带图灵机模型中则必须使用二次时间。如果我们允许运行时间的多项式变化，Cobham-Edmonds 定理指出，“任何两种合理且通用的计算模型中的时间复杂度是多项式相关的”（Goldreich 2008，第 1.2 章）。这为复杂度类 P 奠定了基础，P 是指那些可以在多项式时间内由确定性图灵机解决的决策问题的集合。相应的函数问题集合是 FP。
\subsubsection{重要的复杂度类}
\begin{figure}[ht]
\centering
\includegraphics[width=6cm]{./figures/95c7e425b6bf4fe1.png}
\caption{复杂度类之间关系的表示；L 将是 NL 之外的另一步。} \label{fig_JSFZ_5}
\end{figure}
许多重要的复杂度类可以通过限定算法使用的时间或空间来定义。以下是以这种方式定义的一些重要决策问题的复杂度类：
\begin{table}[ht]
\centering
\caption\label{JSFZ}
\begin{tabular}{|c|c|c|c|}
\hline
\textbf{资源} & \textbf{确定性} & \textbf{复杂度类} & \textbf{资源约束}  \\
\hline 空间 & 非确定性 & NSPACE( \( f(n) \) ) &  \( O(f(n)) \)\\
\hline 空间 & 非确定性 & NL & \( O(\text{poly}(n)) \)\\
\hline 空间 & 非确定性 & NPSPACE & \( O(\text{poly}(n)) \)\\
\hline 空间 & 非确定性 & NEXPSPACE & \( O(2^{\text{poly}(n)}) \)\\
\hline 空间 & 确定性 & DSPACE( \( f(n) \) ) & \( O(f(n)) \)\\
\hline 空间 & 确定性 & L & \( O(\log n) \)\\
\hline 空间 & 确定性 & PSPACE & \( O(\text{poly}(n)) \)\\
\hline 空间 & 确定性 & EXPSPACE & \( O(2^{\text{poly}(n)}) \)\\
\hline 时间 & 非确定性 & NTIME( \( f(n) \) ) & \( O(f(n)) \) \\ 
\hline 时间 & 非确定性 & NP & \( O(\text{poly}(n)) \)\\ 
\hline 时间 & 非确定性 & NEXPTIME & \( O(2^{\text{poly}(n)}) \)\\ 
\hline 时间 | 确定性 | DTIME( \( f(n) \) ) | \( O(f(n)) \)  
\hline 时间 | 确定性 | P | \( O(\text{poly}(n)) \)  
时间 | 确定性 | EXPTIME | \( O(2^{\text{poly}(n)}) \) 
\end{tabular}
\end{table}






   


  
  
  




 