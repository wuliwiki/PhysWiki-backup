% 冯·诺伊曼-博内斯-哥德尔集合论（综述）
% license CCBYSA3
% type Wiki

本文根据 CC-BY-SA 协议转载翻译自维基百科\href{https://en.wikipedia.org/wiki/Von_Neumann\%E2\%80\%93Bernays\%E2\%80\%93G\%C3\%B6del_set_theory}{相关文章}。

在数学基础中，冯·诺依曼–伯奈斯–哥德尔集合论（NBG）是一种公理化集合论，是泽梅洛–弗兰克尔–选择公理集合论（ZFC）的保守扩展。NBG 引入了“类”的概念，类是由公式定义的集合，其量词仅对集合进行量化。NBG 可以定义比集合更大的类，例如所有集合的类和所有序数的类。摩尔斯–凯利集合论（MK）允许通过量词对类进行量化的公式来定义类。NBG 是有限公理化的，而 ZFC 和 MK 则不是。

NBG 的一个关键定理是类存在定理，它声明，对于每个量词仅对集合进行量化的公式，都存在一个类，该类包含满足该公式的集合。这个类是通过用类逐步构造公式来构建的。由于所有集合论公式都是由两种原子公式（成员关系和相等性）和有限多的逻辑符号构成，因此只需要有限多的公理来构建满足这些公式的类。这就是为什么 NBG 是有限公理化的原因。类还用于其他构造、处理集合论悖论，并用于表述全局选择公理，该公理比 ZFC 的选择公理要强。

约翰·冯·诺依曼在 1925 年将类引入集合论。他的理论的原始概念是函数和参数。利用这些概念，他定义了类和集合。\(^\text{[1]}\)保罗·伯奈斯通过将类和集合作为原始概念重新表述了冯·诺依曼的理论。\(^\text{[2]}\)库尔特·哥德尔简化了伯奈斯的理论，用于他对选择公理和广义连续统假设相对一致性的证明。\(^\text{[3]}\)
\subsection{集合论中的类} 
\subsubsection{类的用途} 
在 NBG 中，类有几个用途：
\begin{itemize}
\item 它们产生了集合论的有限公理化。\(^\text{[4]}\)  
\item 它们用于表述“非常强的选择公理”\(^\text{[5]}\)——即全局选择公理：存在一个定义在所有非空集合类上的全局选择函数\( G \)，使得对于每个非空集合\( x \)，都有 \( G(x) \in x \)。  
   这比 ZFC 的选择公理要强：对于每个非空集合的集合\( s \)，存在一个选择函数 \( f \)，定义在\( s \)上，使得对于所有\( x \in s \)，都有\( f(x) \in x \)。  
\item 通过认识到某些类不能是集合，集合论悖论得以解决。例如，假设所有序数的类 \( \text{Ord} \)是一个集合。那么\( \text{Ord} \)是一个按\( \in \)良序的传递集合。所以，根据定义，\( \text{Ord} \)是一个序数。因此，\( \text{Ord} \in \text{Ord} \)，这与\( \in \)是\( \text{Ord} \)的良序性相矛盾。因此，\( \text{Ord} \)不是一个集合。不能是集合的类称为适当类；\( \text{Ord} \)是一个适当类。\(^\text{[6]}\)
\item 适当类在构造中很有用。在他证明全局选择公理和广义连续统假设的相对一致性时，哥德尔使用适当类来构建构造宇宙。他在所有序数的类上构造了一个函数，对于每个序数，通过对先前构造的集合应用集合构建操作来构造一个构造集。构造宇宙就是这个函数的像。\(^\text{[7]}\)
\end{itemize}
\subsubsection{公理模式与类存在定理}  
一旦类被添加到 ZFC 的语言中，就可以轻松地将 ZFC 转换为一个包含类的集合论。首先，添加类理解的公理模式。这个公理模式声明：对于每个仅对集合进行量化的公式\( \phi(x_1, \ldots, x_n) \)，存在一个类\( A \)，由满足该公式的\( n \)-元组组成——即：
\[
\forall x_1 \cdots \forall x_n \left[ (x_1, \ldots, x_n) \in A \iff \phi(x_1, \ldots, x_n) \right].~
\]
然后，替换公理模式被替换为一个使用类的单一公理。最后，ZFC 的外延公理被修改以处理类：如果两个类有相同的元素，则它们是相同的。ZFC 的其他公理没有被修改。\(^\text{[8]}\)

这个理论不是有限公理化的。ZFC 的替换公理模式已被一个单一公理所替代，但类理解的公理模式被引入。

为了产生一个有限公理化的理论，首先将类理解的公理模式替换为有限多个类存在公理。然后，这些公理被用来证明类存在定理，该定理暗示公理模式的每个实例。\(^\text{[8]}\)这个定理的证明只需要七个类存在公理，这些公理用于将公式的构造转换为满足该公式的类的构造。
\subsection{NBG 的公理化}  
\subsubsection{类和集合}  
NBG 有两种类型的对象：类和集合。直观上，每个集合也是一个类。公理化这一点有两种方式。[需要非主要来源] 伯奈斯使用了多种排序逻辑，包含两种排序：类和集合。[2] 哥德尔通过引入原始谓词避免了排序问题：\( \mathfrak{Cls}(A) \)表示 “A 是一个类”，  
\( \mathfrak{M}(A) \)表示 “A 是一个集合”（在德语中，“集合”是“ Menge”）。他还引入了公理，声明每个集合都是一个类，并且如果类\( A \)是某个类的成员，则 \( A \) 是一个集合。[9] 使用谓词是消除排序的标准方式。埃利奥特·门德尔森修改了哥德尔的方法，使得一切都是类，并将集合谓词\( M(A) \)定义为\( \exists C (A \in C) \)。[10] 这种修改消除了哥德尔的类谓词和他的两个公理。

伯奈斯的两排序方法可能一开始看起来更自然，但它创造了一个更复杂的理论。[b] 在伯奈斯的理论中，每个集合有两种表示方式：一种作为集合，另一种作为类。此外，有两个成员关系：第一个，表示为“∈”，用于两个集合之间；第二个，表示为“η”，用于集合与类之间。[2] 这种冗余是多种排序逻辑所需要的，因为不同排序的变量作用于论域的不同子域。

这两种方法之间的差异不会影响可证明的内容，但会影响如何编写命题。在哥德尔的方法中，\( A \in C \)（其中\( A \)和\( C \)是类）是一个有效的命题。在伯奈斯的方法中，这个命题没有意义。然而，如果\( A \)是一个集合，就有一个等效的命题：定义“集合\( a \)表示类\( A \)”如果它们有相同的成员集合——即，\(\forall x (x \in a \iff x \eta A)\)命题\( a \eta C \)（其中集合\( a \)表示类\( A \)）等价于哥德尔的\( A \in C \)。[2]

本文采用的方法是哥德尔加上门德尔森的修改。这意味着 NBG 是一个基于一阶谓词逻辑的公理化系统，具有相等性，其唯一的原始概念是类和成员关系。
