% 树状数组
% keys 树状数组|数据结构|C++

\subsection{基本原理}

若想实现一下两种操作：
\begin{enumerate}
\item 求一个区间内所有元素的和；
\item 修改某个元素的值。
\end{enumerate}

看到求一段序列的和很容易想到前缀和算法，单次查询的时间复杂度为 $\mathcal{O}(1)$，但是修改某个元素的值会影响前缀和数组，最坏为 $\mathcal{O}(n)$。若用普通数组，求一段数的和为 $\mathcal{O}(n)$，修改某个数为 $\mathcal{O}(1)$。若有 $m$ 次询问，两种做法的全局最坏时间复杂度都为 $\mathcal{O}(n \times m)$。树状数组这两种的操作的时间复杂度即不太慢又不太快，单次查询和修改时间复杂度都为 $\mathcal{O}(\log_2 n)$。

树状数组的基本思想来源于二进制拆分优化。对于一个正整数 $x$，它的二进制表示为 $a_{k - 1}, a_{k - 2}, \cdots , a_1, a_0$。可以将 $x$ 用二进制为 $1$ 的位表示出来，$x = 2^{i_1} + 2^{i_2} + \cdots + 2^{i_{k - 1}} + 2^{i_k}$。

其中 $i_1 > i_2 > \cdots > i_k$，可以将 $x$ 划分为 $\mathcal{O}(\log_2 x)$