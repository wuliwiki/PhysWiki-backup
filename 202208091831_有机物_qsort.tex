% 快速排序
% 快速排序|算法|排序|C++

排序算法：

排序算法有很多种，例如：快速排序、归并排序、插入排序、冒泡排序、堆排序等等．

这里只介绍几种常用的排序算法：快速排序、归并排序和堆排序．

\subsection{快速排序：}

快排的主要思想是基于分治．分治的大概流程可以分为三步：分解 -> 解决 -> 合并，快排大致也是这么实现的，我们这里着重讨论一下排序算法．

快速排序的期望时间复杂度为 $\mathcal{O}(n \log_2 n)$，最坏时间复杂度为 $\mathcal{O}(n^2)$，因为快速排序的常数非常小，所以实际效率很高．

快速排序一般分为 $3$ 步：
\begin{enumerate}
\item 找分界点
\item 划分区间
\item 递归处理左右两段
\end{enumerate}

快排与归并排序唯一一点不同的是不用合并，因为子数组都是原址排序的，所以不需要合并操作，数组已经有序．但归并排序的核心是合并操作．

分界点一般确定为 $\dfrac{l+r}{2}$，然后维护两个指针，第一个指针从第一个位置开始走，如果指向的值如果小于分界点，那么第一个指针就往后走，第二个指针从最后一个位置开始往前走，如果第二个指针指向的值大于分界点，那么就往前走．最终使得对于分界点左边的数都 $\leq \text{mid}$，分界点右边的数都 $\geq \text{mid}$，排序成功两个指针一定会相遇，如果最后两个指针没办法再继续走下去的时候，第一个的指针在第二个指针的前面，这种情况一般是：第一个指针指向的元素大于等于分界点了，需要放到右半边、或者是第二个指针指向的元素小于等于分界点，需要放到左半边．那么就需要交换一下两个指针所指向的值，最后再递归左右两边继续做上述的操作．


\begin{lstlisting}[language=cpp]
void quick_sort(int q[], int l, int r)
{
    if (l >= r) return;  // 已经排好序了，直接返回
		
    int i = l - 1, j = r + 1;
    int mid = q[l + r >> 1];  // mid 为分界点
    while (i < j)
    {
        do i ++ ; while (q[i] < mid);
        do j -- ; while (q[j] > mid);
        if (i < j) swap(q[i], q[j]);
    }
    quick_sort(q, l, j), quick_sort(q, j + 1, r); // 递归左右两边
    
    return;
}

\end{lstlisting}


这里使用算法导论中的\textbf{循环不变式}来证明一下快速排序的正确性：