% 原码、反码、补码
% keys 编码|位运算|ALU|计算机组成原理
% license Usr
% type Wiki
\begin{issues}
\issueDraft
\end{issues}

\pentry{数字电路_运算器\nref{nod_Sample}}{nod_eb6a}

\subsection{原码（True form）}

原码即“未经更改”的码，是指一个二进制数左边加上符号位后所得到的码，且当二进制数大于0时，符号位为0；二进制数小于0时，符号位为1；二进制数等于0时，符号位可以为0或1(+0/-0)。

使用n位原码表示\textbf{有符号数}时，范围是 $-(2^{n-1}-1)\sim +(2^{n-1}-1)$。 当n=8时，这个范围就是$-127\sim +127 $

表示\textbf{无符号数}时，由于不需要考虑数的正负，就不需要用一位来表示符号位，n位机器数全部用来表示是数值，这时表示数的范围就是
$0\sim 2^{n}-1$。当$n=8$时，这个范围就是$0\sim 255$

\subsubsection{优点}

简单直观，原码易于人类理解和计算。

\subsubsection{缺点}
原码不能直接被用于运算。
对于加法运算，例如，数学上，1+(-1)=0，但用原码进行运算时，00000001+10000001=10000010，该结果对应数值为-2。显然出错了；
对于减法运算，原码减法需要先将减数取反加 1，才能得到正确的数学结果。


\subsection{反码}

反码同样用于表示整数，特别是在计算机系统内部处理负数时。在反码表示法中，正数的反码与其原码相同；负数的反码则是将原码（除符号位外）的每一位取反。反码解决了一些原码在运算上的问题，但仍然存在如负零的表示以及加法运算中的进位问题。

\subsection{补码}

\subsection{为什么要使用补码}

补码的规则看起来很怪，但对数字电路设计或者说计算机的位运算来说却是友好的编码方式。

\textbf{换一种角度理解：}

在设计一个编码规范时，我们可以把编码后的数围成一个圆（类似一个时钟），我们希望在这个钟表上：
\begin{enumerate}
\item 
无冲突，每个数值的位置都是独一无二，
\item 
连续性，每次运算（+1）相当于时钟顺时针移动一个单位，
\end{enumerate}

从上述角度看,补码是一种很和谐的编码。







% 参考 https://www.cnblogs.com/zhangziqiu/archive/2011/03/30/computercode.html remove by lzq
