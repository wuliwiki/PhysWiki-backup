% 静态和动态编程语言
% license Usr
% type Tutor

\begin{issues}
\issueDraft
\end{issues}

\textbf{静态类型信息在运行时是丢失的， 而动态类型信息在编译时是不可知的。 这就是为什么静态类型和动态类型混用会那么痛苦！}

\textbf{静态类型的唯一作用就是告诉编译器应该选择什么函数地址！否则用户完全可以所有变量都使用 \verb`const void *`。 甚至连每个变量的字节数都不需要用别的变量储存，因为每个函数是知道每个变量的长度的。}

\textbf{最原始的编程：1.变量没有类型，就对应一个地址， 2.没有算符，每个函数对应一个函数地址， 3.}

\textbf{人类很喜欢 overload，机器不喜欢。 即使是 C 语言也有 overload 例如 \verb`+` 算符，只是不能用户定义罢了。 C++ 把 overload 推向了全新的境界。}

C 语言的每一个函数（如果没有被 inline）都对应二进制文件中的一个地址。 二进制文件是写好的，不能运行时修改的。内存中专门有一块区间用于存放程序指令。 CPU 有一个 program counter 就是用于记录当前执行到程序的哪个位置。程序指令在运行时是不可以改动的，写死在程序中的数据（literal）也不可以改动。

函数中的每个本地变量都对应 stack 上的一块固定大小的，相对位置也确定的内存。这些也是编译时候定死的。

运行时可以改变的东西一个是 stack 上的具体数据， 另一个就是 heap 中的动态内存分配以及上面的数据。

静态语言的类型信息在编译后就完全丢失了，除非手动以变量的形式保存。

静态语言和动态语言的最本质区别就是，静态语言的函数和变量都是对应到程序文件中和 stack 中的具体位置的。动态语言一切都是可以改变的，变量并不具有固定地址而是类似于指针，可以指向任何地方。 函数也不对应可执行文件的具体位置而是动态内存中的一些更一般的所谓 “指令” 而不是固定不可更改的机器码（例如 python 的字节码）。 运行时再 “理解” 这些指令，必要的时候调用其他字节码函数，或者把 program counter 转入动态库文件的机器码。 这有点类似于虚拟机。 这就容易理解为什么动态语言比较慢了，因为字节码不可能直接由 cpu 执行，例如一个加法函数把两个变量相加，每次都走到这要现场根据变量的动态类型判断应该调用机器码中哪个版本的加法。就是这些判断，以及多余的 program counter 的跳转导致程序变慢。

那么静态语言如何实现动态语言的灵活性呢？ 属于是 polymorphism。

判断语句和函数调用都可以根据运行时的数据让 program counter 跳到想要的地方。

所以即使有了 \verb`std::any` 也用起来并不顺手，因为我们老想把它和传统类型混用！例如我们希望它具有成员函数 \verb`any::get()` 可以直接输出它所代表的类型的变量。 这样我们就可以写出例如 \verb`a.get() + b.get()` 这样的代码。 但对于内建的 \verb`+` 运算是不可能做到的。

C++ 的 template 也好， function overload 也好， 本质上都是在编译时能让不同的类型自动选择不同的函数，但是函数一旦选择，在运行时就不可能修改了。 非 virtual 的成员函数也是根据 object 在编译时候的类型选择调用的函数地址。 而改函数的返回值的长度首先不能改变。你或许觉得 \verb`get` 可以根据 \verb`any` 的动态类型来判断返回值里面装什么数据， 且把类型也一块返回。 那其实就相当于返回一个 \verb`any` 呀！ 如果返回的类型只能在运行时决定，那么编译时编译器如何决定 \verb`+` 运算应该调用哪个地址的函数呢？ 那我们只好写一个 \verb`operator+()` 函数接收两个 any 并返回一个 any！ 所以如果你想达到动态语言那样的易用效果，就需要把所有函数都变为只接收 any 和只返回 any！ 那就相当于你创建了一个动态类型语言。
