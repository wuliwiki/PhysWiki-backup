% 堆
% keys 堆|数据结构|C++

堆是一个以一颗完全二叉树的结构存储值的数据结构．

堆分为\textbf{大根堆}和\textbf{小根堆}，大根堆的意思是，父节点的值都大于左右两个儿子的值，小根堆则相反．C++ STL 中的 \verb|priority_queue| 优先队列默认就是大根堆．

以一个例题来讲解堆．

维护一个集合，初始时集合为空，支持如下几种操作：
\begin{enumerate}
\item 插入一个数 $x$；
\item 输出当前集合中的最小值；
\item 删除当前集合中的最小值；
\item 删除第 $k$ 个插入的数；
\item 修改第 $k$ 个插入的数，将其变为 $x$．
\end{enumerate}

本题要我们实现一个小根堆，根结点是整课树中最小的结点，父节点永远大于左右两个子节点．
C++ STL 中的堆只能实现前 $3$ 个操作．
\begin{lstlisting}[language=cpp]
priority_queue<int, vector<int>, greater<int>> heap;   // 定义小根堆的方式
int t;
cin >> t;
while (t -- )
{
    string s;
    int x;
    cin >> s;
            
    cin >> x;
    heap.push(x);   // 插入一个数 x

    cout << heap.top() << endl;     // 输出最小值，即栈顶
    heap.pop();     // 删除最小值，即删除栈顶
}
\end{lstlisting}

要想实现随机删除和修改，只能用数组来模拟堆，所以我们讲解一下如何使用数组模拟堆．

首先需要一个数组 \verb|h[M]| 用于存储堆中的元素，由于需要在任意位置进行删除和修改，所以需要多开两个数组 \verb|ph[N]| 和 \verb|hp[N]|．

\verb|ph[i]| 的意思是第 $i$ 个插入的树在堆中的下标是什么，而 \verb|hp[i]| 的意思是在堆中下标是 $i$ 的点是第几个插入的．
比如 \verb|ph[1] = a|，\verb|hp[a] = 1|．

因为是随机插入和删除，所以在堆中删除或者插入某个值的话必定要进行调整．分为 $up$ 操作和 $down$ 操作，$up$ 是如果一个数不符合堆的性质（太小了）就要往上调整，$down$ 也同理，因为某个数不符合堆的性质，就要往下调整．

堆的存储只用开一个一维数组 \verb|h[N]| 就可以了，父节点是 $i$，左子节点就是 $2 \times i$，右子节点就是 $2 \times i + 1$．
$2 \times i$ 可以写成 $\mathtt{u << 1}$ ，$2 \times i + 1$ 可以写成 $\mathtt{u << 1 | 1}$．比如父节点的下标是 $1$，左子节点的下标就是：$2$，右子节点的下标就是：$3$．有一点需要注意：下标必须从 $1$ 开始，如果从 $0$ 开始的话左子节点和右子节点的下标均为 $0$，这样显然是不行的．

插入一个数，就直接在堆的结尾插入一个树就可以了，然后再 $up$ 一遍．

输出最小值直接输出堆顶，一个是最小值．

删除最小值直接删除堆顶不太好删，我们可以把堆的结尾的数与堆顶的数交换，再删除堆的结尾的数（交换完之后堆的结尾的数就是栈顶，即最小值）删除，然后再 $down$ 一遍，这样就实现了删除最小值．

删除任意一个数与删除最小值类似，都是把堆的结尾的数与要删除的数交换，然后再删除堆的结尾的数，最后要注意进行 $up$ 或 $down$ 操作，为了不判断，干脆两个操作都写上，虽然两个函数都执行了，但只有一个函数有影响．

修改任意一个数直接修改就好了，最后也要注意进行 $up$ 或 $down$ 操作．

因为有任意删除和修改操作，涉及到第 $k$ 个插入的数，所以不能直接知道第 $k$ 个插入的数在堆中的下标是多少，所以需要写一个独特的 $\mathtt{swap}$ 操作，就有了前面所提到的两个数组 \verb|ph[N]| 和 \verb|hp[N]|．

具体看一下代码：

第一行的意思是先交换一下 \verb|hp| 数组，再交换一下对应的 \verb|ph| 数组，最后再交换堆中的元素．

举个例子：
第一个插入的数是 $a$，第二个插入的数是 $b$，所以：

\verb|ph[1] = a|、\verb|ph[2] = b|、\verb|hp[a] = 1|、\verb|hp[b] = 2|．

先交换一下 \verb|hp| 数组就有：