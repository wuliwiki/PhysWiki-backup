% 遗传算法
% license CCBYSA3
% type Wiki

（本文根据 CC-BY-SA 协议转载自原搜狗科学百科对英文维基百科的翻译）

在计算机科学和运筹学中，遗传算法是一种受自然选择过程启发的元启发式算法，属于进化算法大类。遗传算法通常依赖于生物启发的算子，如变异、交叉和选择，来生成高质量的优化和搜索问题的解决方案[1]。John Holland在1960年提出了基于达尔文进化论概念的遗传算法；后来，他的学生David E. Goldberg在1989年扩展了遗传算法。[2]

\subsection{方法}
\subsubsection{1.1 优化问题}
在遗传算法中，优化问题的一组候选解（称为个体、生物或表型）向更好的解进化。每个候选解都有一组可以突变和改变的特性（染色体或基因型）；传统上，解决方案用二进制表示为0和1的字符串，但也可以使用其他编码。[3]

进化通常从随机生成的个体种群开始，是一个迭代过程，每次迭代中的种群称为一代。在每一代中，评估种群中每个个体的适应度；适应度通常是被求解优化问题中目标函数的值。更合适的个体是从当前种群中随机选择的，每个个体的基因组被改性（重组，可能随机突变）以形成新一代。新一代候选解随后被用于算法的下一次迭代。通常，当生成的代数达到最大，或者种群达到满意的适应度水平时，算法终止。

典型的遗传算法需要：

1.    解域的遗传表示。

2.    解域的适应度函数。

每个候选解决方案的标准表示是位数组。[3]其他类型和结构的阵列可以以基本相同的方式使用。使这些基因表达变得方便的主要特性是，它们的组成部分由于其固定的大小而容易对齐，这便于简单的交叉操作。也可以使用可变长度表示，但是在这种情况下，交叉实现更加复杂。在遗传规划中研究树状表示，在进化规划中研究图形形式表示；基因表达规划研究了线性染色体和树的混合。

一旦定义了遗传表示和适应度函数，遗传算法就开始初始化一组解，然后通过重复应用变异、交叉、反演和选择算子来改进它。

\textbf{初始化}

人口规模取决于问题的性质，但通常包含数百或数千种可能的解决方案。通常，初始种群是随机生成的，允许所有可能的解决方案范围（搜索空间）。有时，解决方案可能被“播种”到可能找到最佳解决方案的区域。

\textbf{选择}

在每一连续世代中，现有种群的一部分被挑选出来繁殖新一代。通过基于适应度的过程选择个体解决方案，其中更适合的解决方案（由适应度函数度量）通常更有可能被选择。某些选择方法会对每个解决方案的适应度进行评级，并优先选择最佳解决方案。其他方法只对种群的随机样本进行评级，因为前者可能非常耗时。

适应度函数是在遗传表示上定义的，并用来度量表示解的质量。适应度函数总是与问题相关的。例如，在背包问题中，人们想要最大化可以放在某个固定容量背包中的物品的总价值。解决方案的表示可以是位数组，其中每个位代表不同的对象，位的值（0或1）代表对象是否在背包中。不是每一个这样的表示都是有效的，因为物体的大小可能超过背包的容量。如果表示有效，解的适应度是背包中所有对象的值之和，否则为0。

在一些问题中，很难甚至不可能定义适应度表达式；在这些情况下，可以使用模拟来确定表型的适应度函数值（例如，使用计算流体动力学来确定其形状被编码为表型的车辆的空气阻力），或者使用交互式遗传算法。

\textbf{遗传算子}

下一步是从通过遗传算子交叉（也称为重组）和变异的组合选择的解中产生第二代解种群。

对于要生成的每种新解，从之前选择的池中选择一对“亲本”解进行繁殖。通过使用上述交叉和变异方法产生一个“子”解，就产生了一个新的解，它通常具有其“父”的许多特征。为每个新的孩子选择新的父母，并且该过程继续进行，直到产生适当规模的新的解决方案种群。尽管基于双亲使用的繁殖方法更受“生物学启发”，但一些研究[4][5]表明，超过两个父母会产生更高质量的染色体。

这些过程最终导致不同于最初一代的下一代染色体群体。一般来说，通过这一程序，种群的平均适应度会有所提高，因为只有第一代中最好的生物体被挑选出来进行繁殖，还有一小部分不太适应的解决方案。这些不太合适的解决方案确保了父母基因库中的遗传多样性，从而确保了后代的遗传多样性。

对于交叉和变异的重要性，人们意见不一。Fogel （2006）中有许多参考文献支持基于的搜索的重要性。

虽然交叉和变异被认为是主要遗传算子，但也可以在遗传算法中使用其他算子，如重组、殖民灭绝或迁移。[6]

有必要调整突变概率、交叉概率和种群大小等参数，以便为正在处理的问题类找到合理的设置。非常小的突变率可能导致遗传漂移（本质上是非遍历性的）。重组率过高可能导致遗传算法过早收敛。除非采用精英选择，否则过高的突变率可能会导致失去好的解决方案。

\textbf{启发式算法}

除了上面的主要算子之外，可以采用其他启发式算法来使计算更快或更鲁棒。物种形成启发式惩罚过于相似的候选解之间的交叉；这鼓励了种群多样性，并有助于防止过早收敛到不太理想的解决方案。[7][8]

\textbf{终止}

重复这一世代过程，直到达到终止条件。常见的终止条件是：
\begin{itemize}
\item 找到了满足最低标准的解决方案
\item 达到固定的世代数
\item 已达到分配的预算（计算时间/资金）
\item 最高等级的解决方案的适应度正在达到或已经达到一个平稳状态，以致连续的迭代不再产生更好的结果
\item 手动检查
\item 以上各项的组合
\end{itemize}

\subsection{积木块假设}
遗传算法易于实现，但其行为难以理解。特别难以理解的是，为什么这些算法在应用于实际问题时经常能够成功地生成高适应性的解决方案。 积木块假设包括：

1.    通过识别和重组“积木块”（即具有高于平均适应度的低阶、低定义长度图式）来执行自适应的启发式描述。

2.    一种假设，即遗传算法通过隐式和有效地实现这种启发式算法来执行自适应。

Goldberg将启发式描述如下：

“短的、低阶的和高度适合的图式被采样，重新组合（交叉），并被重新采样以形成具有更高潜在适应度的字符串。在某种程度上，通过使用这些特定的图式（积木块），我们降低了问题的复杂性；我们不是通过尝试每一种可能的组合来构建高性能字符串，而是从过去采样的最佳局部解决方案中构建越来越好的字符串。 “因为低定义长度和低阶的高度匹配图式在遗传算法的表现中起着如此重要的作用，我们已经给它们起了一个特殊的名字：积木块。正如一个孩子通过排列简单的木块来建造宏伟的堡垒一样，遗传算法也通过并列排列短的、低阶的、高性能的图式或积木来寻求接近最佳的性能。” [9]
尽管对积木块假设的有效性缺乏共识，但多年来它一直被评估和用作参考。例如，许多分布算法的估计已被提出，试图提供一个假设成立的环境。[10][11]尽管已经报道了某些类型问题的良好结果，但是对于作为遗传算法效率解释的积木块假设的普遍性和/或实用性的怀疑仍然存在。事实上，有相当多的工作试图从分布算法估计的角度来理解它的局限性。[12][13][14]

\subsection{限制}
与其他可选的优化算法相比，遗传算法的使用存在局限性：
\begin{itemize}
\item 复杂问题的重复适应度函数评估通常是人工进化算法中最具禁止性和限制性的部分。寻找复杂高维多模态问题的最佳解决方案通常需要非常昂贵的适应度函数评估。在实际问题中，例如结构优化问题，单个函数评估可能需要几个小时到几天的完整模拟。典型的优化方法不能处理这类问题。在这种情况下，可能有必要放弃精确的评估，而使用计算效率高的近似适应度。显然，融合近似模型可能是令人信服地使用遗传算法解决复杂现实生活问题的最有前途的方法之一。
\item 遗传算法不能随着复杂性而很好地扩展。也就是说，当暴露于突变的元素数量很大时，搜索空间的大小通常会呈指数级增长。这使得在设计引擎、房子或飞机等问题上使用这项技术变得极其困难。为了使这些问题易于进化搜索，它们必须被分解成尽可能简单的表示。因此，我们通常会看到进化算法为风扇叶片而不是发动机编码设计，构建形状而不是详细的构建计划，设计机翼而不是设计整架飞机。复杂性的第二个问题是如何保护已经进化为代表好的解决方案的部件免受进一步破坏性突变的影响，特别是当它们的适应度评估要求它们与其他部件很好地结合时。
\item “更好”的解决方案只是与其他解决方案相比。因此，并不是每个问题都有明确的停止标准。
\item 在许多问题中，遗传算法倾向于收敛于局部最优甚至任意点，而不是问题的全局最优。这意味着它不“知道如何”牺牲短期适应度来获得长期适应度。这种情况发生的可能性取决于适应度地貌的形状：某些问题可能提供一个容易上升到全局最优的途径，其他问题可能使函数更容易找到局部最优。这个问题可以通过使用不同的适应度函数，增加突变率，或者通过使用保持种群解决方案多样性的选择技术来缓解，[15]尽管“没有免费的午餐”定理[16]证明了这个问题没有通用的解决方案。保持多样性的一种常见技术是施加“生态位惩罚”，其中，任何具有足够相似性（生态位半径）的个体群体都增加了惩罚，这将减少该群体在后代中的代表性，从而允许群体中保持其他（不太相似的）个体。然而，这种技巧可能并不有效，这取决于问题的情况。当种群里的大多数彼此过于相似时，另一种可能的技术是简单地用随机产生的个体替换部分群体。多样性在遗传算法（和遗传编程）中很重要，因为交叉同质群体不会产生新的解决方案。在进化策略和进化规划中，多样性并不重要，因为它更依赖于突变。
\item 在动态数据集上操作是困难的，因为基因组很早就开始向对以后的数据不再有效的解决方案收敛。已经有人提出了几种方法来弥补这一缺陷，包括以某种方式增加遗传多样性并防止早期收敛，或者是通过在解决方案质量下降时增加突变的概率（称为触发超突变），又或者通过偶尔将全新的随机产生的元素引入基因库（称为随机移民）。同样，进化策略和进化规划可以用所谓的“逗号策略”来实现，即不维持父母，只从后代中选择新父母。这在动态问题上更有效。
\item 遗传算法不能有效地解决只有一个正确/错误度量的问题（如决策问题），因为没有办法收敛到解决方案上（没有要爬的山）。在这些情况下，随机搜索可能会像遗传算法一样快地找到解决方案。然而，如果情况允许成功/失败试验重复进行，给出（可能）不同的结果，那么成功与失败的比率就提供了一个合适的适应度度量。
\item 对于特定的优化问题和问题实例，就收敛速度而言，其他优化算法可能比遗传算法更有效。替代和互补算法包括进化策略、进化规划、模拟退火、高斯自适应、爬山算法和群体智能（例如蚁群优化、粒子群优化）以及基于整数线性规划的方法。遗传算法的适用性取决于问题的知识量；众所周知的问题通常有更好、更专业的方法。
\end{itemize}

\subsection{变异体}
\subsubsection{4.1 染色体表示}
最简单的算法将每个染色体表示为一个位串。通常，数字参数可以用整数表示，不过也可以使用浮点表示。浮点表示对于进化策略和进化规划来说是自然的。有人提出了实值遗传算法的概念，但实际上用词不当，因为它并不真正代表John Henry Holland在20世纪70年代提出的积木块理论。然而，基于理论和实验结果（见下文），这一理论并非没有支持。基本算法在位级别执行交叉和变异。其他变体将染色体视为数字列表，这些数字是指令表、链表中的节点、散列、对象或任何其他可想象的数据结构的索引。执行交叉和变异为的是尊重数据元素边界。对于大多数数据类型，可以设计特定的变异算子。不同的染色体数据类型似乎对不同的特定问题域起着更好或更坏的作用。

当使用整数的位串表示时，通常使用灰色编码。这样，整数的微小变化就很容易受到突变或交叉影响。已经发现这有助于防止所谓的汉明壁的过早收敛，在汉明壁中，为了将染色体改变为更好的解决方案，必须同时发生很多的突变（或交叉事件）。

其他方法包括使用实数数组而不是位串来表示染色体。图式理论的结果表明，通常字母的值越小，表现越好，但最初令研究者惊讶的是，使用实值染色体获得了良好的结果。这被解释为有限染色体群体中的一组实值形成了一个虚拟字母表（当选择和重组占主导地位时），其基数比浮点表示预期的要低得多。[17][18]

遗传算法可访问问题域的扩展可以通过将几种不同类型的异源编码基因连接到一条染色体上，对解池进行更复杂的编码来实现。[19]这种特殊的方法允许解决需要对问题参数有完全不同的定义域的优化问题。例如，在级联控制器调优的问题中，内部环路控制器结构可以属于三个参数的常规调节器，而外部环路可以实现具有本质不同描述的语言控制器（例如模糊系统）。这种特殊的编码形式需要一种专门的交叉机制，它可以逐段重组染色体，对于复杂适应系统，特别是进化过程建模和仿来说真的是一种有用的工具。