% A-star 算法
% 搜索|BFS|C++

A-star 算法的使用场景和双向 BFS 的差不多，都是如果在一个搜索空间非常大的情况下，可能会遍历非常多无需遍历的状态，导致时间效率非常低。由此可以使用 A* 算法。

A* 算法是在优先队列 BFS 的基础上进行优化的，我们新加了一个\textbf{启发函数}的概念，这样就可以优化搜索空间，降低时间复杂度。这个启发函数一般在 A* 算法上是设计了一个\textbf{估价函数}，在普通的优先队列 BFS 中，每次只会弹出距离当前点比较小点的临点进行更新，不会考虑未来怎么更新，有可能存在一条距离当前点权值比较大的点，但到未来的点的代价可能很小的点。

所以可以添加一个可以对未来的代价进行预估的\textbf{估价函数}，具体地讲，在求最短路的时候，可以存：从起点走到当前点的真实距离，以及从当前点走到终点的估计距离这两个值，在优先队列中使用“当前距离+预估距离”进行扩展，实际意义为当前这条路径到终点的距离。这里的优先队列为小根堆。

A* 算法算法的框架：\begin{lstlisting}[language=cpp]
while (!q.empty())
{
    t <--- 取出优先队列（小根堆）的队头
    当终点第一次出队时，找到了答案，退出循环

    for (枚举 t 的所有出边)
        扩展、将临边入队
}
\end{lstlisting}

当估计距离为 $0$ 时，A* 算法算法变为 Dijkstra。

使用 A* 算法的前提：

设当前状态为 $\texttt{state}$，从起点到当前点的实际距离为 $\texttt{d(state)}$。

\begin{itemize}
\item 从起点到终点的实际距离为 $\texttt{g(state)}$，从起点到终点的估价距离为 $\texttt{f(state)}$。
\item 需要满足 $\texttt{f(state)} \leq \texttt{g(state)}$。
\end{itemize}

简单的证明一下，使用\textsl{反证法}。

假设终点第一次出队时不是最小值。那么此时的 $\texttt{dist}$ 一定严格大于 $\tt d_{\text{最优}}$，此时最优路径中一定存在一个点 $u$，那么存在 $d_u + f_u \leq d_u + g_u = d_{\text{最优}}$。所以 $\texttt{dist} > \tt d_{\text{最优}} \geq d_u + f_u$。此时 $d_u + f_u$ 是一定严格小于终点第一次出队的距离 $\tt dist$ 的，又因为是小根堆，队列中存在一个比已经出队的更新的一个元素，矛盾。

证毕。

性质：A* 算法只能保证\textbf{终点第一次出队的时候是最小值，并不能保证其他点第一次出队是最小值，并且每个点不一定会扩展（入队）一次。}

\begin{figure}[ht]
\centering
\includegraphics[width=14cm]{./figures/Astar_1.png}
\caption{请添加图片描述} \label{Astar_fig1}
\end{figure}
