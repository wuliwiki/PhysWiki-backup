% 哈希表（综述）
% license Usr
% type Wiki

（本文根据 CC-BY-SA 协议转载自原搜狗科学百科对英文维基百科的翻译）

在计算领域中，哈希表(hash map)是一种实现关联数组抽象数据类型的数据结构，这种结构可以将关键码映射到给定值。哈希表使用哈希函数计算桶单元或槽位数组中的索引，从中可以找到所需的给定值。

理想情况下，哈希函数会将每个关键码分配给一个唯一的存储桶单元，但是大多数哈希表设计都使用不完美的哈希函数，这可能会导致哈希冲突，也就是哈希函数会为多个关键码生成相同的索引。这种冲突必须以某种方式解决。

在维度良好的哈希表中，每次查找的平均成本(指令数)与表中存储的记录个数无关。许多哈希表设计还允许任意插入和删除键值对，每次操作的平均成本(摊销[1])为常数。[2][3]

在许多情况下，哈希表比搜索树或任何其他表查找结构平均效率更高。因此，它们被广泛应用于多种计算机软件中，特别是用于关联数组、数据库索引、缓存和集合。

\subsection{ 哈希（散列）法}
散列的概念是将条目(键/值对) 存储分布在桶单元数组中。设定一个关键码，用哈希算法计算一个索引，该索引建议在哪里可以找到条目:

散列的概念是将条目(键/值对) 存储分布在桶单元数组中。设定一个关键码，用哈希算法计算一个索引，该索引建议在哪里可以找到条目:
\begin{lstlisting}[language=cpp]
index = f(key, array_size)
\end{lstlisting}
这通常分两步完成:
\begin{lstlisting}[language=cpp]
hash = hashfunc(key)
index = hash % array_size
\end{lstlisting}
在这种方法中，哈希与数组大小无关，然后使用模运算符(\%)将其缩减为一个索引指数值(介于0和array _ size 1之间的数字)。

在数组大小是二的幂($n$次方)的情况下，剩余的操作被减少到屏蔽，这提高了速度，但是会增加散列函数性能不佳的问题。[5]

\subsubsection{1.1 选择一个哈希(散列)函数}
一个好的哈希函数和实现算法对于良好的哈希表性能至关重要，但可能难以实现。[6]

一个基本要求是哈希函数应该让哈希值均匀分布。非均匀分布增加了冲突的次数和解决冲突的成本。均匀性有时很难通过设计来保证，但可以使用统计检验方法进行经验评估，例如离散均匀分布的皮尔逊卡方检验。[7][8]

仅对于应用程序中出现的哈希表大小，才需要均匀分布。特别是，如果使用动态调整大小的操作，来使哈希表大小精确加倍和减半，那么只有当哈希表大小是二的幂(n次方)时，哈希函数才需要一致。在这里，索引可以被计算为哈希函数的某个数位范围。另一方面，一些哈希算法更愿意哈希表的大小设定为质数，[9] 再由模数运算提供一些额外的混合操作；这对于一个设计不佳的哈希函数尤其有用。

对于开放式定址方案，散列函数还应该避免堆积现象的产生，即两个或多个关键码被映射到连续的槽位。这种堆积现象可能会导致查找成本急剧上升，即使这个哈希表的装填因子很低且冲突很少。流行的乘法哈希法[2] 据称很容易产生这类堆积现象。

通过使用模数约减或数位屏蔽技术，加密哈希函数可以为任何大小尺寸的哈希表提供良好的哈希函数。[9]如果存在恶意用户试图通过向服务器提交旨在哈希表中产生大量冲突的请求来破坏网络服务的风险，加密哈希函数也能进行适当的处理。 当然，也可以通过更为简便的方法来避免这种恶意的风险(例如对数据进行秘密盐处理，或者使用通用散列函数)。加密哈希函数的缺点是计算速度通常较慢，这意味着对于任意大小的哈希表，在不强调均匀性是必须的情况下，非加密哈希函数可能是更好的选择。

\subsubsection{1.2 完美散列函数}
如果能提前知道所有的关键码，那么就可以使用一个完美的散列函数来创建一个没有冲突的完美哈希表。如果使用最小完美哈希，哈希表中的每个存储位置都可以得到使用。

完美的散列允许在所有情况下进行常数时间查找。这与大多数链接和开放式寻址方法形成对比，在这些方法中，平均查找时间很短。但当所有的关键码散列到几个给定值时，查找时间就可能非常长O(n)。

\subsection{关键统计}
关键码统计哈希表的一个关键统计数据是装填因子，定义为
\begin{equation}
\text{load factor} = \frac{n}{k}~
\end{equation}
其中
\begin{itemize}
\item 其中$n$是填入哈希表中记录个数(条目数)。
\item $k$是桶的数量(哈希表的长度)。
\end{itemize}
随着装填因子的增大，哈希表的查找速度变得更慢，甚至可能无法工作(取决于所使用的方法)。哈希表的预期常数时间属性是假定装填因子保持在某个界限以下。因为桶的数量一般是固定的，查找时间随着条目数量的增加而增加，因此无法得到所需的常数时间。作为一个实际的应用例子，Java 10程序语言中哈希表的默认装填因子是0.75，这“在查找时间和空间成本之间达到了一个很好的平衡”。[10]

其次，可以检查每个桶单元中条目数的差异。例如，两个表都有1000个条目和1000个桶，一个在每个桶中正好填有一个条目，另一个在同一个桶中填入所有条目。很明显，散列法在第二种情况下不起作用。

并不是装填因子低就特别有益。随着装填因子接近0，哈希表中未使用区域的比例会增加，但搜索成本不一定会降低。这导致了内存的浪费。

\subsection{碰撞分辨率}
冲突处理方法当散列一大组可能关键码的随机子集时，散列(哈希)冲突实际上是不可避免的。例如，如果将2，450个关键码散列到一百万个桶中，即使是完全均匀的随机分布，根据生日问题法则，至少有两个关键码散列到同一个槽位的概率大约为95\%。

因此，几乎所有哈希表实现都有一些冲突解决策略来处理这些事件。下面描述了一些常见的策略。所有这些方法都要求关键码(或指向它们的指针)与相关给定值一起存储在哈希表中。

\subsubsection{3.1 独立链接}
\begin{figure}[ht]
\centering
\includegraphics[width=14.25cm]{./figures/425151ecc827cefb.png}
\caption{通过单独链接解决散列冲突。} \label{fig_HXB_1}
\end{figure}
分离链接法在称为分离链接的方法中，每个桶单元都是独立的，并且有某种具有相同索引的条目列表。哈希表操作的时间是查找桶单元的时间(它是常数)加上遍历列表的时间。

在一个好的散列(哈希)表中，每个桶都有零个或一个条目，有时有两个或三个，但很少超过这个数量。因此，对于这些情况，在时间和空间上有效的结构是优先选择的。而对每个桶单元中相当多的条目都有效的结构并不需要或者不要求这样。如果这些情况经常发生，散列函数需要修复。

\textbf{链接列表的单独链接}

带有链表的分离链接法具有链表的链式哈希表很受欢迎，因为它们只需要具有简单算法的基本数据结构，并且可以使用不适合其他方法的简单哈希函数。

哈希表操作的成本是扫描所选存储桶的条目找到所需关键码的成本。如果关键码的分布足够均匀，查找的平均成本仅取决于每个桶所分布的关键码的平均数量，也就是说，它与装填因子大致成正比例关系。

因此，即使哈希表中条目数$n$远远大于槽位数，链式哈希表仍然有效。例如，具有1000个插槽和10，000个存储关键码的链式哈希表(加载因子10)比10，000个插槽的表(加载因子1)慢五到十倍；但是仍然比普通的顺序列表快1000倍。

对于分离链接法，最坏的情况是所有条目都被插入到同一个桶中，在这种情况下哈希表是无效的，它的查找成本是遍历桶单元中所有数据结构。如果后者是一个线性列表，查找过程可能不得不扫描它的所有条目，因此这种最坏的情况下的查找时间成本也与表中条目的数量$n$成正比例关系。

桶链通常使用条目添加到桶单元的顺序进行连续搜索。如果装填因子很大，并且某些关键码比其他关键码更有可能出现，那么使用向前移动启发式重新排列链可能是有效的。只有当装填因子很大(大约10或更多)，或者如果散列分布可能非常不均匀，或者即使在最坏的情况下也要必须保证良好的性能时，才值得考虑使用更复杂的数据结构，例如平衡搜索树。然而，在那些情况下，使用更大的哈希表和/或更好的散列函数可能更有效。

链式哈希表也继承了链表的缺点。当存储小键值对时，每个条目记录中下一个指针的空间开销可能很大。另一个缺点是遍历链表的缓存性能差，使得处理器缓存无效。

\textbf{带有表头单元分离链接法}

\begin{figure}[ht]
\centering
\includegraphics[width=14.25cm]{./figures/a614fe32b0c6eeb0.png}
\caption{单独链接和桶单元数组中中的头记录产生的哈希冲突。} \label{fig_HXB_2}
\end{figure}
一些链接实现将每个链的第一条记录存储在自身的槽位数组中。[3]大多数情况下，指针遍历次数减少一次。目的是提高哈希表访问的缓存效率。

缺点是空桶占用的空间与只填入一个条目的桶相同。为了节省空间，这样的哈希表通常被分割成多个槽位，且槽位数量与存储条目数量一样多，这意味着许多槽位能够插入两个或更多条目。

\textbf{与其他结构分开链接}

带有其他数据结构的分离链接法我们可以使用支持所需操作的任何其他数据结构来代替列表。例如，通过使用自平衡二叉搜索树，理论上来讲，普通哈希表操作(插入、删除、查找)的最坏情况常数时间可以降低到O（log n）而不是O（$n$）。但是，这给哈希表实现带来了额外的复杂性，并且可能会导致较小哈希表的性能更差，在这些哈希表中插入和平衡搜索树所需的时间大于对列表的所有元素执行线性搜索所需的时间。哈希表使用桶的自平衡二叉搜索树的一个现实例子是Java版本8中的哈希表类。[11]

称为数组哈希表的变型体使用动态数组来存储所有的条目，这些条目被散列到同一个槽位。[12][13][14] 每个新插入的条目都被附加到分配给插槽的动态数组的末尾。动态数组以精确匹配的方式调整大小，这意味着它只根据需要来增加字节的多少。人们发现，有些替代技术诸如通过块的大小或页面来增加数组可以提高插入性能，但需要更多的空间。这种变化更有效地利用了中央处理器缓存和转换后备缓冲器(TLB)，因为插槽条目是按照顺序存储在内存中的。它还省去了链表所需的下一个指针，从而节省了空间。尽管频繁调整数组大小，但发现操作系统由此而产生的空间开销(如内存碎片)很小。

所谓的动态完美哈希对这种方法的使用进行了详细的说明,[15]其中包含$k$个条目的桶被组织成一个具有$k^2$个插槽位的完美哈希表。虽然它使用了更多的内存($n$个条目使用$n^2$个插槽位，最坏情况下使用$n\times k$个插槽位，平均情况下使用$n\times k$个插槽)，但这种变体保证了最坏情况下常数查找时间和较低的分摊插入时间。我们也可以为每个桶使用一个融合树数据结构，以高概率实现所有操作的常数时间。[16]

\subsubsection{3.2 开放定址法主标题: 开放定址法}
\begin{figure}[ht]
\centering
\includegraphics[width=14.25cm]{./figures/8c77a843470c5b5d.png}
\caption{请添加图片标题} \label{fig_HXB_3}
\end{figure}
