% 计算机文件备份基础（科普）

\subsection{最原始的多版本备份方法}
为了防止文件被误删、误改、硬盘损坏等带来的文件丢失， 最普通原始的多版本方法大概要数复制粘贴了。 假设你笔记本上所有重要的文件都在一个文件夹 \verb|我的文件夹| 中。 为了安全起见你买了一个甚至多个移动硬盘， 每隔一段时间把它复制到硬盘中的 \verb|我的文件夹-备份| 中， 用不同的版本号（例如日期）命名为： \verb|我的文件夹v20230101|， \verb|我的文件夹v20230108| 等等。 但这样做的缺点是大量重复的文件会浪费移动硬盘空间， 写入这些文件也同样会浪费许多时间。 这时你很可能会发现一些支持\textbf{增量备份}的备份软件。 本文介绍一些备份的基本常识， 以及提供一些简单免费但非常可靠的备份方案。 本文对文件备份的主要目标是备份方案能够\textbf{验证每个文件和备份文件中每比特的数据}都是完好无损的。

在进一步讲解各种不同的增量备份方法之前， 我们需要简单了解计算机文件的构成， 常用增量备份软件的原理， 以及如何检查其内容的完整性的一些方法。

\subsection{计算机文件的构成}
计算机的硬盘中会有不同的文件系统， 例如 Windows 的 NTFS， MacOS 的 APFS， Linix 的 Ext4 等。 他们在一些特性上有所不同， 本文中不具体讨论， 但要注意若想要移动硬盘支持所有操作系统， 一般推荐在格式化时选择 exFAT 文件系统。

一些几乎所有文件系统都支持的信息：
\begin{itemize}
\item \textbf{文件名（含路径）}： 注意不同的文件系统或操作系统对名字的长度和包含的字符有不同的要求。
\item \textbf{文件内容}： 由若干\textbf{字节（Byte， 缩写 B）}构成， 每个字节有 \textbf{8 个比特（bit， 缩写 b）}， 每个比特就是一个二进制的 0 或 1。 文本文件（如 txt）和二进制文件（如 exe）的不同仅仅在于如何用 0 和 1 编码信息， 并无本质区别。
\item \textbf{文件大小}： 即上一条中文件内容的大小， 注意文件名的长度不会影响文件大小。 注意这并不是额外的信息， 而是包含在\textbf{文件内容}中的。 一些常见的单位有 \textbf{kB}（1000 byte）， \textbf{MB}（1000 kB）， \textbf{GB}（1000 MB）， \textbf{TB}（1000 MB）等。 注意严格来说这里都是 1000 而不是 1024（即 $2^{10}$）， 为了区分， 后者经常表示为 \textbf{kiB}（1024 byte）， \textbf{MiB}（1024 kB）， \textbf{GiB}（1024 MiB）等（注意这个定义并不是所有系统都严格遵守，例如 Windows 的文件管理器会把 MiB 显示为 MB 等）。 顺便提一下， 网速的快慢通常用 \textbf{bit/s} 来表示， 即每秒钟传输的比特数。 例如 8Mbit/s 就是 1MB/s。
\item \textbf{修改时间}： 文件被修改的时间。 注意该时间并不是非常可靠， 软件和硬件\footnote{例如硬盘老化出现坏点， 也就是 bit rot， 但出现的概率较小。}上的错误都有可能导致文件内容被改变而修改时间没有更新。 更常见地， 也有可能修改时间更新了但文件内容实际上没有更新（例如打开文件不做任何修改就保存）。 修改时间属于文件的\textbf{元数据（meta data）}， 不储存于\textbf{文件内容}中。 另一个类似的元数据是\textbf{创建时间}， 但并不是所有文件系统都支持， 本文不讨论。 可见如果用户想稳定地记录关于文件的一些时间， 最好记录在\textbf{文件内容}中（例如在 word 文档中手动写下创建和修改时间）而不是依赖元数据。
\end{itemize}

本文假设我们只需要备份\textbf{文件名}（含路径）和\textbf{文件内容}（含文件大小）。

\subsection{增量备份}
常用的备份软件在进行增量备份时通常通过\textbf{文件大小}或\textbf{修改时间（元数据）}的变化来判断文件是否发生变化， 从而在每次增量备份时只备份它认为发生改变的文件。 但我们已经看到， 依赖这两个信息判断文件内容是否改变并不绝对可靠， 软件或硬件错误都可能在不改变二者的情况下改变甚至破坏\textbf{文件内容}。 而一旦这些错误发生， 通常的增量备份软件并不能检测到。 更糟糕的是， 备份硬盘本身也可能随着其老化和磨损出现坏点， 而常用的备份软件一般不具有检查备份数据完整性的功能。 即使使用不同硬盘进行多重备份， 也无法定期检验哪个备份是完好的。

\subsection{文件指纹：哈希值}
检查文件内容完整性的最佳办法要数\textbf{哈希（hash）}了。 一个文件的哈希值是根据其文件内容（注意不包括文件名）生成的一串固定长度的字符（通常为几十个 16 进制字符）， 常见的哈希算法有 \textbf{SHA1}， \textbf{SHA256}， \textbf{MD5} 等。 哈希值虽然不能还原出文件本身， 但它的计算却依赖于文件内容的每一个字节。 绝大多数情况下， 我们可以认为哈希值改变则文件内容改变， 反之亦然。\footnote{一个重要的例外是对一些不太安全的哈希算法， 有可能会被黑客恶意篡改而保持其哈希值不变。}在一些较为严肃的文件下载网页中， 通常会提供下载文件的哈希值， 用户下载完成后可以用这个哈希值来验证文件的完整性。

著名的源码版本管理软件 Git （被用于管理 Linux 内核源码）就是使用文件的 SHA1 哈希值来判断文件夹中哪些文件发生了改变， 以及检查历史镜像（备份）的完整性。 事实上， Git 也可以用于对任何类型的文件进行增量备份\upref{gitBac}， 但这对普通用户来说可能具有较高的学习门槛。 另外， Git 在处理大文件时速度较慢（笔者的测试中写入速度只有 15-40 MB/s）。

\subsection{用网盘增量备份}
这是笔者给大部分读者推荐的备份方案。 现在大部分网盘都支持所谓的 “秒传” 功能， 其原理就是网盘客户端在任何用户上传每个文件前都计算其哈希值， 如果任何其他用户已经上传过具有相同哈希值的文件（当然也会参考文件大小等）， 那么客户端就会取消上传， 而在用户的网盘中添加服务器上指纹相同的文件的一个 “快捷方式”。 这也是为什么一些网盘可以用极低费用提供巨大储存空间。

另外， 规模较大的网盘服务商基本都有规范的服务器管理和多重备份方案， 所以只要网盘不下架， 数据安全性往往比个人的储存方式要高得多。

还是假设你所有文件都在文件夹 \textbf{我的文件} 中要用网盘进行增量备份， 只需要定期上传该文件夹， 然后用不同的版本号重命名即可。 即使你的文件在第一次备份时都无法秒传， 但在之后的备份中都将大部分可以秒传（除了新增的和修改的）。 支持秒传的网盘往往也会具有文件查重功能， 可以快速根据哈希值扫描出你网盘中出现的重复文件， 并 “删除” 日期较老的文件。 这么做以后， 在网盘中只有最新版本的 \verb|我的文件20XXXX| 中有所有文件， 而更老版本的 \verb|我的文件20XXXX| 文件夹中所有重复的文件都将被删掉， 但这并没有太大影响， 反而有助于判断不同版本间哪些文件发生了改变， 每个文件的所有历史版本都依然会保留。

\subsubsection{文件加密}
当然， 支持秒传的网盘也有一些弊端。 例如网盘提供商可以 “根据相关法规” 迅速找到并批量删除所有用户网盘中具有某些哈希值的文件。 这对于有数据洁癖或强迫症的用户来说是无法忍受的。 为了保护隐私及数据安全性， 我们可以选择先把文件批量加密（或加密压缩）到移动硬盘（顺便作为本地备份）， 再上传到网盘。 但需要注意的是， 通常的加密算法会通过随机数进行 “加盐” 处理， 所以同一个文件即使用相同的密码加密两次得到的两个加密文件指纹也不一样。 这就会使网盘的秒传以及文件查重功能失效。 解决这个问题的具体办法见 “用网盘增量备份文件\upref{PanBak}”。

\subsection{用硬盘进行简单的增量备份}
这里提供一个 python 脚本， 具有如下功能。

\begin{itemize}
\item 脚本的\textbf{备份目录}中的每个子文件夹（姑且叫做 \verb|文件夹1, 文件夹2...|）， 如果需要备份， 就手动创建空白文件 \verb|sha1sum.txt|。
\item 脚本的\textbf{输出目录中}会生成一些文件夹 \verb|文件夹1.sync, 文件夹2.sync...| 其中每个文件夹都有不同版本的备份如 \verb|文件夹1.sync/文件夹1.v0|， \verb|文件夹1.sync/文件夹1.v1|。 \textbf{版本号}可以由用户指定。
\item 快速检查模式：
\end{itemize}

首先在要备份的文件夹（\verb|我的文件夹|）中创建一个文件 

\addTODO{backup.py： 基本就相当于 “网盘增量备份” 的本地版}
