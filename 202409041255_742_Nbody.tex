% N 体问题软件（天体物理）
% license Xiao
% type Tutor

\begin{issues}
\issueDraft
\end{issues}


在物理学和天文学中，N体模拟是对粒子动力学系统的模拟，这些粒子通常受到物理力（如重力）的影响（关于其他应用，请参阅N体问题）。N体模拟是天体物理学中广泛使用的工具，从研究像地-月-日系统这样的少体系统的动力学，到理解宇宙大尺度结构的演化。在物理宇宙学中，N体模拟用于研究非线性结构形成的过程，如星系丝和星系晕，这些过程受到暗物质的影响。直接N体模拟用于研究星团的动力学演化。

模拟处理的“粒子”可能或可能不对应于本质上是粒子状的物理对象。例如，一个星团的N体模拟可能每个恒星有一个粒子，因此每个粒子都具有一定的物理意义。另一方面，一个气体云的模拟不能为气体的每个原子或分子都有一个粒子，因为这将需要每个摩尔物质大约1023个粒子（见阿伏伽德罗常数），因此一个单一的“粒子”将代表一些更大的气体量（通常使用平滑粒子流体动力学实施）。这个量不需要具有任何物理意义，但必须在准确性和可管理的计算机要求之间做出妥协。

暗物质在星系的形成中扮演着重要角色。暗物质粒子的相空间密度f的时间演化可以通过无碰撞的玻尔兹曼方程来描述。在方程中，v是速度，Φ是引力势能，由泊松方程给出。这两个耦合方程在一个膨胀的宇宙背景下求解，该背景由弗里德曼方程控制，在确定了暗物质粒子的初始条件之后。用于初始化暗物质粒子的位置和速度的常规方法涉及在均匀的笛卡尔格子内或类似玻璃的粒子配置中移动粒子。这是通过使用线性理论近似或低阶摄动理论来完成的。

在直接引力N体模拟中，N个粒子在它们相互引力作用下的动力学方程被数值积分，而不做任何简化近似。这些计算用于个体物体之间的相互作用对系统演化很重要的情况。

第一个直接引力N体模拟是由Erik Holmberg在1941年在隆德天文台进行的，他通过数学等价性确定了恒星在相遇星系之间的力——在恒星的位置放置灯泡，并通过光电管测量恒星位置的方向光通量，运动方程可以通过努力积分。然后，Sebastian von Hoerner在德国海德堡的天文计算研究所进行了第一个纯计算模拟。Sverre Aarseth在剑桥大学（英国）致力于开发一系列用于天体物理应用的高效N体代码，这些代码使用自适应（分层）时间步长、Ahmad-Cohen邻域方案和近场遭遇的规则化。规则化是一种数学技巧，用于消除牛顿引力定律中两个粒子相互接近时的奇异性。Sverre Aarseth的代码用于研究星团、行星系统和银河核的动力学。

许多模拟足够大，以至于在建立一个弗里德曼-勒梅特-罗伯逊-沃克宇宙学时，广义相对论的影响是显著的。这在模拟中被纳入为一个演化的距离度量（或尺度因子），在共动坐标系统中，这导致粒子在共动坐标中减速（也由于它们物理能量的红移）。然而，广义相对论的贡献和重力的有限速度通常可以忽略，因为典型的动力学时间尺度与模拟的光穿越时间相比长，粒子和粒子速度引起的时空曲率很小。这些宇宙学模拟的边界条件通常是周期性的（或环面的），以便模拟体积的一边与另一边相匹配。

直接引力N体模拟
广义相对论模拟
计算优化

N体模拟在原理上很简单，因为它们只涉及积分定义粒子运动的6N个常微分方程。实际上，涉及的粒子数量N通常非常大（典型的模拟包括数百万，千年模拟包括一百亿），需要计算的粒子-粒子相互作用的数量以N^2的顺序增加，因此直接积分微分方程可能在计算上非常昂贵。因此，通常使用一些改进方法。

数值积分通常使用小时间步长的方法进行，如跃迁积分。然而，所有的数值积分都会导致误差。较小的步骤给出较低的误差，但运行更慢。跃迁积分在时间步长上大致是二阶的，其他积分器如龙格-库塔方法可以达到四阶精度或更高。

最简单的改进之一是每个粒子都有自己的时间步长变量，这样具有非常不同动力学时间的粒子不必都以最短时间的速率向前演化。

有两种基本的近似方案可以减少这类模拟的计算时间。这些可以将计算复杂度降低到O(N log N)或更好，但以牺牲精度为代价。

在树方法中，如巴恩斯-赫特模拟，通常使用八叉树将体积划分为立方体单元，只有来自附近单元的粒子之间的相互作用需要单独处理；来自远距离单元的粒子可以集体视为一个位于远距离单元质心的大粒子（或作为低阶多极展开）。这可以大幅减少必须计算的粒子对相互作用的数量。为了防止模拟被计算粒子-粒子相互作用所淹没，必须在模拟的密集部分细化为更小的单元，这些部分每个单元包含许多粒子。对于粒子分布不均匀的模拟，Callahan和Kosaraju的良序对分解方法每次迭代的时间为O(n log n)。

另一种可能性是粒子网格方法，其中空间在网格上离散化，并且为了计算引力势，假设粒子被分配到网格周围的2x2顶点之间。势能Φ可以通过泊松方程找到

其中G是牛顿常数，ρ是密度（网格点处的粒子数量）。快速傅里叶变换可以通过进入频率域高效地解决这个问题，在那里泊松方程具有简单的形式

其中是共动波数，帽子表示傅里叶变换。由于，现在可以通过乘以并计算逆傅里叶变换来找到引力场

（或者计算逆变换，然后使用其他方法）。由于这种方法受到网格大小的限制，实际上使用更小的网格或某种其他技术（如与树或简单的粒子-粒子算法结合）来计算小尺度力。有时使用自适应网格，在模拟的密集区域网格单元要小得多。

几种不同的引力摄动算法被用来相当准确地估计太阳系中物体的路径。

人们经常决定将卫星放置在固定轨道上。紧密绕地球运行的卫星的路径可以从围绕地球中心的二体椭圆轨道开始准确建模，并加上由于地球的扁率、太阳和月球的引力吸引、大气阻力等小的修正。可以找到一个固定轨道，而不需要计算卫星的实际路径。

一个小行星、彗星或远程航天器的路径通常可以从围绕太阳的二体椭圆轨道开始准确建模，并加上来自它们已知轨道上较大行星的引力吸引的小修正。

系统的长期路径的一些特征可以直接计算。不需要将任何特定粒子的实际路径作为中间步骤来计算。这些特征包括李雅普诺夫稳定性、李雅普诺夫时间、来自遍历理论的各种测量等。

尽管典型的模拟中有数百万或数十亿个粒子，但它们通常对应于一个非常大的质量的实际粒子，通常是10^9个太阳质量。这可能会引入粒子之间的短程相互作用问题，如两个粒子二元系统的形成。由于粒子旨在代表大量暗物质粒子或恒星群，这些二元系统是物理上不合理的。为了防止这种情况，使用了一个软化的牛顿力定律，它在短距离上不会像反平方半径那样发散。大多数模拟通过在有限大小的单元上运行模拟很自然地实现了这一点。重要的是以这样的方式实现离散化过程，以至于粒子总是对自己施加消失的力。

软化是N体技术中使用的一种数值技巧，用于防止粒子彼此靠得太近时数值发散（力变为无穷大）。这是通过对每个粒子的规则化引力势能进行修改来实现的

其中是软化参数。软化参数的值应该设置得足够小，以保持模拟的真实性。

N体模拟提供了关于大规模暗物质分布和暗物质晕结构的发现。根据冷暗物质的模拟，大规模上暗物质的总体分布并不完全均匀。相反，它显示出类似网络的结构，由空洞、墙、丝和晕组成。此外，模拟表明，晕的集中度与质量、初始波动谱和宇宙学参数等因素之间的关系与晕的实际形成时间有关。特别是，质量较低的晕倾向于更早形成，因此由于它们形成时宇宙的较高密度，它们的集中度更高。晕的形状被发现偏离完美的球形。通常发现晕是拉长的，并且越来越向中心变成长轴状。然而，暗物质与重子之间的相互作用会影响暗物质晕的内部结构。需要模拟暗物质和重子来研究小尺度结构。

许多模拟只模拟冷暗物质，因此只包括引力。将重子、轻子和光子纳入模拟会大大增加它们的复杂性，通常必须对基础物理进行激进的简化。然而，这是一个极其重要的领域，许多现代模拟现在正试图理解在星系形成过程中发生的过程，这可能解释了星系偏差。

Reif和Tate[6]证明，如果n体可达性问题定义如下——给定满足固定电静态势法则的n个物体，确定一个物体是否在给定的时间界限内到达目标球，我们要求poly(n)位的精度，目标时间是poly(n)，则该问题属于PSPACE。

另一方面，如果问题是物体最终是否到达目标球，那么这个问题是PSPACE-hard。这些界限基于光线追踪获得的类似复杂性界限。

N体模拟的最简单实现是轨道物体的朴素传播；朴素意味着作用在轨道物体上的唯一力是它们彼此施加的引力。在面向对象的编程语言中，如C++，一些样板代码对于建立所需的基本数学结构以及数据容器非常有用。

N体模拟的结果
将重子、轻子和光子纳入模拟
计算复杂性
示例模拟
常见样板代码

传播；即状态向量，因此是向量，以及包含这些数据的一些基本对象，以及轨道物体的质量。这种方法也适用于其他类型的N体模拟；模拟带电点质量的模拟将使用类似的方法，但力将是由于电场的相互作用而产生的吸引或排斥。无论如何，粒子的加速度是合力向量除以粒子的质量的结果：

包含粒子运动学数据的程序稳定且可扩展的方法的一个例子是使用固定长度数组，这在优化的代码中允许容易的内存分配和预测消耗的资源；如以下C++代码所示：

注意，OrbitalEntity包含足够的空间用于状态向量，其中：

，物体在笛卡尔空间中的位置向量的投影，

，物体在笛卡尔空间中的位置向量的投影，

，物体在笛卡尔空间中的位置向量的投影，

，物体在笛卡尔空间中的速度向量的投影，

，物体在笛卡尔空间中的速度向量的投影，

，物体在笛卡尔空间中的速度向量的投影。



此外，OrbitalEntity还包含足够的空间用于质量值。

通常，N体模拟将基于某种类型的运动方程；其中，大多数将依赖于某种初始配置来“播种”模拟。在依赖于某种引力或电势的系统中，模拟实体上的力与其速度无关。因此，为了播种模拟的力，只需要初始位置，但这不会允许传播——需要初始速度。考虑一个围绕恒星运行的行星——它没有运动，但受到其宿主恒星的引力吸引。随着时间的推移，随着时间步的增加，它将根据其加速度获得速度。对于给定的瞬间，t，由于其邻近质量体，一个物体的加速度是独立于其速度的，然而，对于时间步，t，由于传播的固有速度依赖性，位置的变化显著不同。在基本传播机制中，如下面将使用的辛普莱克欧拉方法，物体在t+dt的位置仅依赖于它在t的速度，因为位置的变化是通过计算的

没有加速度，t是静态的，然而，从只看到位置的观察者的角度来看，需要两个时间步才能看到速度的变化。

通过采取行星等效点质量从中心恒星的平均距离，可以实现类似太阳系的模拟。为了保持代码简单，将使用基于半长轴和平均速度的非严格方法。必须在配置物体之前为这些物体预留内存空间；为了允许可扩展性，可以使用malloc命令：

其中N_ASTEROIDS是一个将暂时保持为0的变量，但允许用户自行决定将来包含大量小行星。配置模拟的一个关键步骤是建立模拟的时间范围，t_0到t_end，以及将推进模拟前进的增量时间步：

初始化模拟参数
OrbitalEntity* orbital_entities = malloc(sizeof(OrbitalEntity) * (9 + N_ASTEROIDS));
orbital_entities[0] = { 0.0,0.0,0.0, 0.0,0.0,0.0, 1.989e30 }; // 一个类似于太阳的恒星 orbital_entities[1] = { 57.909e9,0.0,0.0, 0.0,47.36e3,0.0, 0.33011e24 }; // 一个类似于水星的行星 orbital_entities[2] = { 108.209e9,0.0,0.0, 0.0,35.02e3,0.0, 4.8675e24 }; // 一个类似于金星的行星 orbital_entities[3] = { 149.596e9,0.0,0.0, 0.0,29.78e3,0.0, 5.9724e24 }; // 一个类似于地球的行星 orbital_entities[4] = { 227.923e9,0.0,0.0, 0.0,24.07e3,0.0, 0.64171e24 }; // 一个类似于火星的行星 orbital_entities[5] = { 778.570e9,0.0,0.0, 0.0,13e3,0.0, 1898.19e24 }; // 一个类似于木星的行星 orbital_entities[6] = { 1433.529e9,0.0,0.0, 0.0,9.68e3,0.0, 568.34e24 }; // 一个类似于土星的行星 orbital_entities[7] = { 2872.463e9,0.0,0.0, 0.0,6.80e3,0.0, 86.813e24 }; // 一个类似于天王星的行星 orbital_entities[8] = { 4495.060e9,0.0,0.0, 0.0,5.43e3,0.0, 102.413e24 }; // 一个类似于海王星的行星
1 2 3
4
5
6
7
8
9
10
11
double t_0 = 0; double t = t_0;

上述建立的位置和速度被解释为在t=t_0时是正确的。
模拟的范围逻辑上是t在上述范围内的时期。
整个模拟可能包括数百、数千、数百万、数十亿或有时数万亿个时间步。在基本层面上，每个时间步（对于由于受到力的作用而移动的粒子的模拟）涉及
计算每个物体上的力
计算每个物体的加速度（a = F/m）
计算每个物体的速度（v = a * dt）
计算每个物体的新位置（x = v * dt + x0）

上述可以通过一个while循环非常简单地实现，该循环在上述范围内继续存在：

double dt = 86400; double t_end = 86400 * 365 * 10; // 大约十年的时间，以秒为单位 double BIG_G = 6.67e-11; // 引力常数
3 4 5
传播
while (t < t_end) { for (size_t m1_idx = 0; m1_idx < 9 + N_ASTEROIDS; m1_idx++) { Vector3 a_g = { 0,0,0 };
 for (size_t m2_idx = 0; m2_idx < 9 + N_ASTEROIDS; m2_idx++) { if (m2_idx != m1_idx) { Vector3 r_vector;
 r_vector.e[0] = orbital_entities[m1_idx].e[0] - orbital_entities[m2_idx].e[0]; r_vector.e[1] = orbital_entities[m1_idx].e[1] - orbital_entities[m2_idx].e[1]; r_vector.e[2] = orbital_entities[m1_idx].e[2] - orbital_entities[m2_idx].e[2];
 double r_mag = sqrt( r_vector.e[0] * r_vector.e[0] + r_vector.e[1] * r_vector.e[1] + r_vector.e[2] * r_vector.e[2]);
 double acceleration = -1.0 * BIG_G * (orbital_entities[m2_idx].e[6]) / pow(r_mag, 2.0);
 Vector3 r_unit_vector = { r_vector.e[0] / r_mag, r_vector.e[1] / r_mag, r_vector.e[2] / r_mag };
 a_g.e[0] += acceleration * r_unit_vector.e[0]; a_g.e[1] += acceleration * r_unit_vector.e[1]; a_g.e[2] += acceleration * r_unit_vector.e[ 






\href{https://en.wikipedia.org/wiki/Orbit_modeling}{轨道微扰理论}

\href{https://en.wikipedia.org/wiki/N-body_problem}{多体问题 - 维基百科}

\href{https://arxiv.org/abs/0806.3950v1}{多体算法综述}

\subsection{多体软件}

\href{https://en.wikipedia.org/wiki/Computational_astrophysics}{计算天体物理 - 维基百科}

\href{https://wwwmpa.mpa-garching.mpg.de/gadget/}{Gadget}

\href{https://people.ast.cam.ac.uk/~sverre/web/pages/nbody.htm}{NBODY6}

\href{https://www.boulder.swri.edu/~hal/swift.html}{Swift}

\href{https://www.sns.ias.edu/~starlab/}{Starlab}

\href{http://www.manybody.org/modest/}{MODEST}
