% 归并排序
% 算法|排序|归并排序|C++

上文介绍了快速排序\upref{qsort}，本文将介绍\textbf{归并排序}．

归并排序也是基于分治实现的．

归并排序的算法步骤：
\begin{enumerate}
\item 确定分界点为 $\dfrac{l + r}{2}$，把一个序列分成两个大小为 $\dfrac{n}{2}$ 的子序列；
\item 先递归排序两个子序列；
\item 合并两个已排好序的子序列．
\end{enumerate}

归并排序的核心就是\textbf{归并}这一步，首先把一个序列分成两个子序列，然后维护两个指针，第一个指针指向第一个子序列的开头，第二个指针指向第二个子序列的开头．其实归并操作就是把两个子序列的值存到一个序列中输出出来，具体的做法是：每次判断一下两个指针所指向的值哪一个更小，把较小的的值插入到答案数组中，如果发现其中一个序列的指针已经直到末尾了，那么就退出循环，直接把另一个子序列的后面的值接到答案数组中（如图 $1$ 所示）．前提得保证两个子序列中的值都已排好序．

\begin{figure}[ht]
\centering
\includegraphics[width=10.25cm]{./figures/Msort_2.png}
\caption{终止} \label{Msort_fig2}
\end{figure}

\textbf{时间复杂度：}

归并排序的期望时间复杂度为 $\mathcal{O}(n \log_2 n)$，最坏时间复杂度也为 $\mathcal{O}(n \log_2 n)$，可以发现，归并的这一步操作是维护两个指针，两个指针会遍历完整个序列，所以时间复杂度为 $\mathcal{O}(n)$，然后递归每一层，每层有 $\frac{n}{2}$、$\frac{4}{n}$...，一共有 $\log_2 n$ 层，每层时间复杂度为 $\mathcal{O}(n)$，所以总共时间复杂度为 $\mathcal{O}(n \log_2 n)$．

\begin{figure}[ht]
\centering
\includegraphics[width=14.25cm]{./figures/Msort_1.png}
\caption{算法导论中的递归树} \label{Msort_fig1}
\end{figure}

