% 原码、反码、补码
% keys 编码|位运算|ALU|计算机组成原理
% license Usr
% type Wiki
\begin{issues}
\issueDraft
\end{issues}

\subsection{原码（True form）}

原码即“未经更改”的码，是指一个二进制数左边加上符号位后所得到的码，且当二进制数大于0时，符号位为0；二进制数小于0时，符号位为1；二进制数等于0时，符号位可以为0或1(+0/-0)。

使用n位原码表示\textbf{有符号数}时，范围是 $-(2^{n-1}-1)\sim +(2^{n-1}-1)$。 当n=8时，这个范围就是$-127\sim +127 $；表示\textbf{无符号数}时，由于不需要考虑数的正负，就不需要用一位来表示符号位，n位机器数全部用来表示是数值，这时表示数的范围就是$0\sim 2^{n}-1$。当$n=8$时，这个范围就是$0\sim 255$。


\textbf{优点：}
简单直观，原码易于人类理解和计算。

\textbf{缺点：}原码不能直接被用于运算。
对于加法运算，例如，数学上，1+(-1)=0，但用原码进行运算时：


\begin{example}{}
00000001+10000001=10000010
\end{example}


该结果对应数值为-2。显然出错了；
对于减法运算，原码减法需要先将减数取反加 1，才能得到正确的数学结果。

也就是说：\textbf{原码的运算，必须将符号位和其他位分开}，这就增加了硬件的开销和复杂性。

\subsection{反码(1's complement)}

在反码表示法中，正数和0的反码与其原码相同；负数的反码则是将原码（除符号位外）的每一位取反。

\textbf{优点：}
可以直接用于减法运算。
与原码表示相同符号的数，反码也相同。
此特性可使加法电路同时可以运算减法。

\textbf{缺点：}原码不能直接被用于运算。
不能直接用于加法运算。
0 的反码为其自身，这与其他数不同。

\subsection{补码}

\subsection{为什么要使用补码}

补码的规则看起来很怪，但对数字电路设计或者说计算机的位运算来说却是友好的编码方式。

\textbf{换一种角度理解：}

在设计一个编码规范时，我们可以把编码后的数围成一个圆（类似一个时钟），我们希望在这个钟表上：
\begin{enumerate}
\item 
无冲突，每个数值的位置都是独一无二，
\item 
连续性，每次运算（+1）相当于时钟顺时针移动一个单位，
\end{enumerate}

从上述角度看,补码是一种很和谐的编码。







% 参考 https://www.cnblogs.com/zhangziqiu/archive/2011/03/30/computercode.html remove by lzq
