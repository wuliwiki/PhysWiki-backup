% 矩阵的储存
% 行主序|列主序

\subsection{行主序和列主序}
由于在计算机内存中所有数据都是按顺序排成一行， 所以在储存矩阵时我们就有两种选择， 一是把所有行首尾相接， 叫做\textbf{行主序（row-major）}， 二是把所有列首尾相接， 叫\textbf{列主序（column-major）}． 例如对于 $2 \times 2$ 的矩阵， 列主序下， 矩阵元在内存中的顺序依次 $(0, 0), (1, 0), (0, 1), (1, 1)$， 而在行主序下顺序为 $(0, 0), (0, 1), (1, 0), (1, 1)$．

在 fortran 和 Matlab 中\footnote{Matlab 最初就是由 fortran 写的}， 语言自带的矩阵都是列主序， 而在 C/C++ 中如果用指针的指针（或数组的数组）来表示矩阵， 得到的将会是行主序． 当然， 由于 C++ 的灵活性， 我们完全可以创造行主序和列主序两种不同的矩阵类．

在我们用双索引寻找矩阵元时， 我们需要先将其转换为单索引． 假设矩阵尺寸为 $N_1 \times N_2$， 那么
\begin{equation}
\leftgroup{
n &= i + N_1 j &\quad &\text{（列主序）}\\
n &= N_2 i + j &\quad &\text{（行主序）}
}\end{equation}

行主序和列主序也可以延申至高维矩阵， 如果使用列主序， 那么当我们在内存中按顺序读取数据的时候， 第 1 个索引（index）将变化得最快， 第 2 个索引变化得第二快， 最后得索引变化得最慢． 行主序则相反， 最后的索引变化得最快， 而第一个最慢． 例如 4 维数组的多索引变为单索引的公式为
\begin{equation}
\leftgroup{
n &= i_1 + N_1 i_2 + N_1 N_2 i_3 + N_1 N_2 N_3 i_4 &\quad &\text{（列主序）}\\
n &= N_2 N_3 N_4 i_1 + N_3 N_4 i_2 + N_4 i_3 + i_4  &\quad&\text{（行主序）}
}\end{equation}
从性能角度来看， 单索引要比多个索引要快．

至于由单索引计算多索引， 我们可以用整数除法（向下取整） “\lstinline|/|” 和求余符号 “\%”%未完成： 适用 lstinline， 等 bug 修好了以后
， 例如对列主序的矩阵有
\begin{equation}
\leftgroup{
i &= n \% N\\
j &= n / N
}\end{equation}
