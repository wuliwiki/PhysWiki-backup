% 区间动态规划
% keys 动态规划|算法|C++

区间动态规划和普通的动态规划的区别是状态的定义集中在了区间上。像树形 $\tt dp$ 一般是由子结点从下往上递归的计算父结点，而区间 $\tt dp$ 是\textbf{由子区间逐步计算}得来的。所以状态表示也会发生一定的改变，一般来说，状态表示定义为：$f(l, r)$ 表示一段区间。而状态转移一般由两个小区间合并为一个大区间，这需要具体问题具体分析。

我们还是通过一道具体的例题来学习区间 $\tt dp$，\href{https://www.luogu.com.cn/problem/P1775}{石子合并}。

题目要求合并的是相邻的两堆，若没有相邻两堆这个限制，可以使用贪心，故思考区间 $\tt dp$。

\textbf{状态表示}：
\begin{itemize}
\item 集合：$f(l, r)$ 表示从第 $l$ 堆石子到第 $r$ 堆石子合并为一堆的合并方式的集合。
\item 属性：合并代价的最小值。
\end{itemize}

\textbf{状态计算：}

不难看出最后一个肯定是由相邻的两堆合并得到的，而这两堆又是由更小的相邻的两堆合并得到的，所以较大的一堆一定是由较小的相邻的两堆合并得到的。

这样的话，划分集合的依据可以定义为最后一次合并的位置来划分集合。所以可以枚举分界点，\textbf{答案就是合并的两堆已计算好的代价加合并这两堆的代价}，即整个区间的和。这样就将集合划分成了 $k - 1$ 个子集，$k$ 为区间的长度（$r - l + 1$）。第一个子集左边 $1$ 个石子，右边 $k - 1$ 个石子、第二个子集左边 $2$ 个石子，右边 $k - 2$ 个石子，以此类推划分集合。

由此可得状态转移方程：$f(l, r) = \min(f(l, k) + f(k + 1, r) + \sum^{r}_{i = l}a_i, (l \leq k < r))$。